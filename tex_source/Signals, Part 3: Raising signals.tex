\subsection{How do I send a signal to a process from the
shell?}\label{how-do-i-send-a-signal-to-a-process-from-the-shell}

You already know one way to send a \texttt{SIG\_INT} just type
\texttt{CTRL-C}\\From the shell you can use \texttt{kill} (if you know
the process id) and \texttt{killall} (if you know the process name)

\begin{verbatim}
# First let's use ps and grep to find the process we want to send a signal to
$ ps au | grep myprogram
angrave  4409   0.0  0.0  2434892    512 s004  R+    2:42PM   0:00.00 myprogram 1 2 3

#Send SIGINT signal to process 4409 (equivalent of `CTRL-C`)
$ kill -SIGINT 4409

#Send SIGKILL (terminate the process)
$ kill -SIGKILL 4409
$ kill -9 4409
\end{verbatim}

\texttt{killall} is similar except that it matches by program name. The
next two example, sends a \texttt{SIGINT} and then \texttt{SIGKILL} to
terminate the processes that are running \texttt{myprogram}

\begin{verbatim}
# Send SIGINT (SIGINT can be ignored)
$ killall -SIGINT myprogram

# SIGKILL (-9) cannot be ignored! 
$ killall -9 myprogram
\end{verbatim}

\subsection{How do I send a signal to a process from the running C
program?}\label{how-do-i-send-a-signal-to-a-process-from-the-running-c-program}

Use \texttt{raise} or \texttt{kill}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{raise(}\DataTypeTok{int} \NormalTok{sig); }\CommentTok{// Send a signal to myself!}
\DataTypeTok{int} \NormalTok{kill(pid_t pid, }\DataTypeTok{int} \NormalTok{sig); }\CommentTok{// Send a signal to another process}
\end{Highlighting}
\end{Shaded}

For non-root processes, signals can only be sent to processes of the
same user i.e.~you cant just SIGKILL my processes! See kill(2) i.e.~man
-s2 for more details.

\subsection{How do I send a signal to a specific
thread?}\label{how-do-i-send-a-signal-to-a-specific-thread}

Use \texttt{pthread\_kill}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{pthread_kill(pthread_t thread, }\DataTypeTok{int} \NormalTok{sig)}
\end{Highlighting}
\end{Shaded}

In the example below, the newly created thread executing \texttt{func}
will be interrupted by \texttt{SIGINT}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pthread_create(&tid, NULL, func, args);}
\NormalTok{pthread_kill(tid, SIGINT);}
\NormalTok{pthread_kill(pthread_self(), SIGKILL); }\CommentTok{// send SIGKILL to myself}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Will
\texttt{pthread\_kill(\ threadid,\ SIGKILL)} kill the process or
thread?}{Will pthread\_kill( threadid, SIGKILL) kill the process or thread?}}\label{will-pthreadux5fkill-threadid-sigkill-kill-the-process-or-thread}

It will kill the entire process. Though individual threads can set a
signal mask, the signal disposition (the table of handlers/action
performed for each signal) is \emph{per-proces}s not \emph{per-thread}.
This means\\\texttt{sigaction} can be called from any thread because you
will be setting a signal handler for all threads in the process.

\subsection{How do I catch (handle) a signal
?}\label{how-do-i-catch-handle-a-signal}

You can choose a handle pending signals asynchronously or synchronously.

Install a signal handler to asynchronously handle signals use
\texttt{sigaction} (or, for simple examples, \texttt{signal} ).

To synchronously catch a pending signal use \texttt{sigwait} (which
blocks until a signal is delivered) or \texttt{signalfd} (which also
blocks and provides a file descriptor that can be \texttt{read()} to
retrieve pending signals).

See \texttt{Signals,\ Part\ 4} for an example of using \texttt{sigwait}
