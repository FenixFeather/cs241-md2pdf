\chapter{C Programming}ntroduction to
C?}\label{want-a-quick-introduction-to-c}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Keep reading for the quick crash-course to C Programming below
\item
  Then see the {[}{[}C Gotchas wiki page\textbar{}C Programming, Part 3:
  Common Gotchas{]}{]}.
\item
  And learn about {[}{[}text I/O \textbar{}C Programming, Part 2: Text
  Input And Output{]}{]}.
\item
  Kick back relax with
  \href{http://cs-education.github.io/sys/\#}{Lawrence's intro videos}
\item
  \^{} and the same link includes a virtual machine-in-a-browser you can
  play with
\item
  Or watch some old CS241 slides {[}{[}CS241 Old
  Slides\textbar{}\url{https://subversion.ews.illinois.edu/svn/fa14-cs241/_shared/past-lectures/}{]}{]}
\end{itemize}

\section{External resources}\label{external-resources}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \href{http://www.ccs.neu.edu/course/com3620/parent/C-for-Java-C++/c-for-c++-alt.html}{C
  for C++/Java Programmers}
\item
  \href{http://www.lysator.liu.se/c/bwk-tutor.html}{C Tutorial by Brian
  Kernighan}
\item
  \href{http://c-faq.com/}{c faq}
\item
  \href{http://gribblelab.org/CBootCamp/index.html}{C Bootcamp}
\item
  Add your favorite resources here
\end{itemize}

\section{Crash course intro to C}\label{crash-course-intro-to-c}

\emph{Warning new page} Please fix typos and formatting mistakes for me
and add useful links too.*

\subsection{How do you write a complete hello world program in
C?}\label{how-do-you-write-a-complete-hello-world-program-in-c}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <stdio.h>}
\DataTypeTok{int} \NormalTok{main() \{ }
    \NormalTok{printf(}\StringTok{"Hello World}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \KeywordTok{return} \DecValTok{0}\NormalTok{; }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Why do we use
`\texttt{\#include\ stdio.h}'?}{Why do we use \#include stdio.h?}}\label{why-do-we-use-include-stdio.h}

We're lazy! We don't want to declare the \texttt{printf} function. It's
already done for us inside the file `\texttt{stdio.h}'. The \#include
includes the text of the file as part of our file to be compiled.

\subsection{How are C strings
represented?}\label{how-are-c-strings-represented}

As characters in memory. The end of the string includes a NULL (0) byte.
So ``ABC'' requires four(4) bytes. The only way to find out the length
of a C string is to keep reading memory until you find the NULL byte. C
characters are always exactly one byte each.

When you write a string literal \texttt{"ABC"} in an expression the
string literal evaluates to a char pointer (char *), which points to the
first byte/char of the string. This means \texttt{ptr} in the example
below will hold the memory address of the first character in the string.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \NormalTok{*ptr = }\StringTok{"ABC"}
\end{Highlighting}
\end{Shaded}

\subsection{How do you declare a
pointer?}\label{how-do-you-declare-a-pointer}

A pointer refers to a memory address. The type of the pointer is useful
- it tells the compiler how many bytes need to be read/written.

\begin{verbatim}
int *ptr1;
char *ptr2;
\end{verbatim}

\subsection{How do you use a pointer to read/write some
memory?}\label{how-do-you-use-a-pointer-to-readwrite-some-memory}

if `p' is a pointer then use ``*p" to write to the memory address(es)
pointed to by p.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{*ptr = }\DecValTok{0}\NormalTok{; }\CommentTok{// Writes some memory.}
\end{Highlighting}
\end{Shaded}

The number of bytes written depends on the pointer type.

\subsection{What is pointer
arithmetic?}\label{what-is-pointer-arithmetic}

You can add an integer to a pointer. However the pointer type is used to
determine how much to increment the pointer. For char pointers this is
trivial because characters are always one byte:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \NormalTok{*ptr = }\StringTok{"Hello"}\NormalTok{; }\CommentTok{// ptr holds the memory location of 'H'}
\NormalTok{ptr += }\DecValTok{2}\NormalTok{; }\CommentTok{//ptr now points to the first'l'}
\end{Highlighting}
\end{Shaded}

If an int is 4 bytes then ptr+1 points to 4 bytes after whatever ptr is
pointing at.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \NormalTok{*ptr = }\StringTok{"ABCDEFGH"}\NormalTok{;}
\DataTypeTok{int} \NormalTok{*bna = (}\DataTypeTok{int} \NormalTok{*) ptr;}
\NormalTok{bna +=}\DecValTok{1}\NormalTok{; }\CommentTok{// Would cause iterate by one integer space (i.e 4 bytes on some systems)}
\NormalTok{ptr = (}\DataTypeTok{char} \NormalTok{*) bna;}
\NormalTok{printf(}\StringTok{"%s"}\NormalTok{, ptr);}
\CommentTok{/* Notice how only 'EFGH' is printed. Why is that? Well as mentioned above, when performing 'bna+=1' we are increasing the **integer** pointer by 1, (translates to 4 bytes on most systems) which is equivalent to 4 characters (each character is only 1 byte)*/}
\KeywordTok{return} \DecValTok{0}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{What is a void pointer?}\label{what-is-a-void-pointer}

A pointer without a type (very similar to a void variable). You can
think of this as a raw pointer, or just a memory address. You cannot
directly read or write to it because the void type does not have a size.

This is often used when either a datatype you're dealing with is unknown
or when you're interfacing C code with other programming languages.

\subsection{\texorpdfstring{Does \texttt{printf} call write or does
write call
\texttt{printf}?}{Does printf call write or does write call printf?}}\label{does-printf-call-write-or-does-write-call-printf}

\texttt{printf} calls \texttt{write}. \texttt{printf} includes an
internal buffer so, to increase performance \texttt{printf} may not call
\texttt{write} everytime you call \texttt{printf}. \texttt{printf} is a
C library function. \texttt{write} is a system call and as we know
system calls are expensive. On the other hand \texttt{printf} uses a
buffer which suits our needs better at that point

\subsection{How do you print out pointer values? integers?
strings?}\label{how-do-you-print-out-pointer-values-integers-strings}

Use format specifiers ``\%p'' for pointers, ``\%d'' for integers and
``\%s'' for Strings.\\A full list of all of the format specifiers is
found \href{http://www.cplusplus.com/reference/cstdio/printf/}{here}

Example of integer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{num1 = }\DecValTok{10}\NormalTok{;}
\NormalTok{printf(}\StringTok{"%d"}\NormalTok{, num1); }\CommentTok{//prints num1}
\end{Highlighting}
\end{Shaded}

Example of integer pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{*ptr = (}\DataTypeTok{int} \NormalTok{*) malloc(}\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{));}
\NormalTok{*ptr = }\DecValTok{10}\NormalTok{;}
\NormalTok{printf(}\StringTok{"%p}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, ptr); }\CommentTok{//prints the address pointed to by the pointer}
\NormalTok{printf(}\StringTok{"%p}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, &ptr); }\CommentTok{/*prints the address of pointer -- extremely useful}
\CommentTok{when dealing with double pointers*/}
\NormalTok{printf(}\StringTok{"%d"}\NormalTok{, *ptr); }\CommentTok{//prints the integer content of ptr}
\KeywordTok{return} \DecValTok{0}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Example of string:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \NormalTok{*str = (}\DataTypeTok{char} \NormalTok{*) malloc(}\DecValTok{256} \NormalTok{* }\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{char}\NormalTok{));}
\NormalTok{strcpy(str, }\StringTok{"Hello there!"}\NormalTok{);}
\NormalTok{printf(}\StringTok{"%p}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, str); }\CommentTok{// print the address in the heap}
\NormalTok{printf(}\StringTok{"%s"}\NormalTok{, str);}
\KeywordTok{return} \DecValTok{0}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\href{https://www.cs.bu.edu/teaching/c/string/intro/}{Strings as
Pointers \& Arrays @ BU}

\subsection{How would you make standard out be saved to a
file?}\label{how-would-you-make-standard-out-be-saved-to-a-file}

Simplest way: run your program and use shell redirection\\e.g.

\begin{verbatim}
./program > output.txt

#To read the contents of the file,
cat output.txt
\end{verbatim}

More complicated way: close(1) and then use open to re-open the file
descriptor.\\See
{[}{[}\url{http://angrave.github.io/sysassets/web/chapter1.html}{]}{]}

\subsection{What's the difference between a pointer and an array? Give
an example of something you can do with one but not the
other.}\label{whats-the-difference-between-a-pointer-and-an-array-give-an-example-of-something-you-can-do-with-one-but-not-the-other.}

\begin{verbatim}
char ary[] = "Hello";
char *ptr = "Hello";
\end{verbatim}

Example

The array name points to the first byte of the array. Both \texttt{ary}
and \texttt{ptr} can be printed out:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \NormalTok{ary[] = }\StringTok{"Hello"}\NormalTok{;}
\DataTypeTok{char} \NormalTok{*ptr = }\StringTok{"Hello"}\NormalTok{;}
\CommentTok{// Print out address and contents}
\NormalTok{printf(}\StringTok{"%p : %s}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, ary, ary);}
\NormalTok{printf(}\StringTok{"%p : %s}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, ptr, ptr);}
\end{Highlighting}
\end{Shaded}

The array is mutable, so we can change its contents (be careful not to
write bytes beyond the end of the array though). Fortunately `World' is
no longer than 'Hello"

In this case, the char pointer \texttt{ptr} points to some read only
memory (where the statically allocated string literal is stored), so we
cannot change those contents.

\begin{verbatim}
strcpy(ary, "World"); // OK
strcpy(ptr, "World"); // NOT OK - Segmentation fault (crashes)
\end{verbatim}

We can, however, unlike the array, we change \texttt{ptr} to point to
another piece of memory,

\begin{verbatim}
ptr = "World"; // OK!
ptr = ary; // OK!
ary = (..anything..) ; // WONT COMPILE
// ary is doomed to always refer to the original array.
printf("%p : %s\n", ptr, ptr);
strcpy(ptr, "World"); // OK because now ptr is pointing to mutable memory (the array)
\end{verbatim}

What to take away from this is that pointers * can point to any type of
memory while C arrays {[}{]} can only point to memory on the stack. In a
more common case, pointers will point to heap memory in which case the
memory referred to by the pointer CAN be modified.

\subsection{\texorpdfstring{\texttt{sizeof()} returns the number of
bytes. So using above code, what is sizeof(ary) and
sizeof(ptr)?}{sizeof() returns the number of bytes. So using above code, what is sizeof(ary) and sizeof(ptr)?}}\label{sizeof-returns-the-number-of-bytes.-so-using-above-code-what-is-sizeofary-and-sizeofptr}

\texttt{sizeof(ary)}: \texttt{ary} is an array. Returns the number of
bytes required for the entire array (5 chars + zero byte = 6
bytes)\\\texttt{sizeof(ptr)}: Same as sizeof(char *). Returns the number
bytes required for a pointer (e.g.~4 or 8 for a 32 bit or 64 bit
machine)

\subsection{Which of the following code is incorrect or correct and
why?}\label{which-of-the-following-code-is-incorrect-or-correct-and-why}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{* f1(}\DataTypeTok{int} \NormalTok{*p) \{}
    \NormalTok{*p = }\DecValTok{42}\NormalTok{;}
    \KeywordTok{return} \NormalTok{p;}
\NormalTok{\} }\CommentTok{// This code is correct;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{* f2() \{}
    \DataTypeTok{char} \NormalTok{p[] = }\StringTok{"Hello"}\NormalTok{;}
    \KeywordTok{return} \NormalTok{p;}
\NormalTok{\} }\CommentTok{// Incorrect!}
\end{Highlighting}
\end{Shaded}

Explanation: An array p is created on the stack for the correct size to
hold H,e,l,l,o, and a null byte i.e. (6) bytes. This array is stored on
the stack and is invalid after we return from f2.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{* f3() \{}
    \DataTypeTok{char} \NormalTok{*p = }\StringTok{"Hello"}\NormalTok{;}
    \KeywordTok{return} \NormalTok{p;}
\NormalTok{\} }\CommentTok{// OK}
\end{Highlighting}
\end{Shaded}

Explanation: p is a pointer. It holds the address of the string
constant. The string constant is unchanged and valid even after f3
returns.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{* f4() \{}
    \DataTypeTok{static} \DataTypeTok{char} \NormalTok{p[] = }\StringTok{"Hello"}\NormalTok{;}
    \KeywordTok{return} \NormalTok{p;}
\NormalTok{\} }\CommentTok{// OK}
\end{Highlighting}
\end{Shaded}

Explanation :The array is static meaning it exists for the lifetime of
the process (static variables are not on the heap or the stack).

\subsection{How do you look up information C library calls and system
calls?}\label{how-do-you-look-up-information-c-library-calls-and-system-calls}

Use the man pages. Note the man pages are organized into sections.
Section 2 = System calls. Section 3 = C libraries.\\Web: Google ``man7
open''\\shell: man -S2 open or man -S3 printf

\subsection{How do you allocate memory on the
heap?}\label{how-do-you-allocate-memory-on-the-heap}

Use malloc. There's also realloc and calloc.\\Typically used with cast
and a sizeof. e.g.~enough space to hold 10 integers

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{*space = (}\DataTypeTok{int} \NormalTok{*) malloc(}\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{) * }\DecValTok{10}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\subsection{What's wrong with this string copy
code?}\label{whats-wrong-with-this-string-copy-code}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \NormalTok{mystrcpy(}\DataTypeTok{char}\NormalTok{*dest, }\DataTypeTok{char}\NormalTok{* src) \{ }
  \CommentTok{// void means no return value   }
  \KeywordTok{while}\NormalTok{( *src ) \{ dest = src; src ++; dest++; \}  }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In the above code it simply changes the dest pointer to point to source
string. Also the nul bytes is not copied. Here's a better version -

\begin{verbatim}
  while( *src ) { *dest = *src; src ++; dest++; } 
  *dest = *src;
\end{verbatim}

Note it's also usual to see the following kind of implementation, which
does everything inside the expression test, including copying the nul
byte.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{while}\NormalTok{( (*dest++ = *src++ )) \{\};}
\end{Highlighting}
\end{Shaded}

\subsection{How do you write a strcpy
replacement?}\label{how-do-you-write-a-strcpy-replacement}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Use strlen+1 to find the zero byte... }
\DataTypeTok{char}\NormalTok{* mystrdup(}\DataTypeTok{char}\NormalTok{*source) \{}
   \DataTypeTok{char} \NormalTok{*p = (}\DataTypeTok{char} \NormalTok{*) malloc ( strlen(source)+}\DecValTok{1} \NormalTok{);}
   \NormalTok{strcpy(p,source);}
   \KeywordTok{return} \NormalTok{p;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{How do you unallocate memory on the
heap?}\label{how-do-you-unallocate-memory-on-the-heap}

Use free!

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{*n = (}\DataTypeTok{int} \NormalTok{*) malloc(}\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{));}
\NormalTok{*n = }\DecValTok{10}\NormalTok{;}
\CommentTok{//Do some work}
\NormalTok{free(n);}
\end{Highlighting}
\end{Shaded}

\subsection{What is double free error? How can you avoid? What is a
dangling pointer? How do you
avoid?}\label{what-is-double-free-error-how-can-you-avoid-what-is-a-dangling-pointer-how-do-you-avoid}

A double free error is when you accidentally attempt to free the same
allocation twice.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{*p = malloc(}\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{));}
\NormalTok{free(p);}

\NormalTok{*p = }\DecValTok{123}\NormalTok{; }\CommentTok{// Oops! - Dangling pointer! Writing to memory we don't own anymore}

\NormalTok{free(p); }\CommentTok{// Oops! - Double free!}
\end{Highlighting}
\end{Shaded}

The fix is firstly to write correct programs! Secondly, it's good
programming hygiene to reset pointers\\once the memory has been freed.
This ensures the pointer cant be used incorrectly without the program
crashing.

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p = NULL; }\CommentTok{// Now you can't use this pointer by mistake}
\end{Highlighting}
\end{Shaded}

\subsection{What is an example of buffer
overflow?}\label{what-is-an-example-of-buffer-overflow}

Famous example: Heart Bleed (performed a memcpy into a buffer that was
of insufficient size).\\Simple example: implement a strcpy and forget to
add one to strlen, when determining the size of the memory required.

\subsection{\texorpdfstring{What is `typedef' and how do you use
it?}{What is typedef and how do you use it?}}\label{what-is-typedef-and-how-do-you-use-it}

Declares an alias for a types. Often used with structs to reduce the
visual clutter of having to write `struct' as part of the type.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{float} \NormalTok{real; }
\NormalTok{real gravity = }\DecValTok{10}\NormalTok{;}
\CommentTok{// Also typedef gives us an abstraction over the underlying type used. }
\CommentTok{// For example in the future we only need to change this typedef and }
\CommentTok{// in we wanted out physics library to use doubles instead of floats.}

\KeywordTok{typedef} \KeywordTok{struct} \NormalTok{link link_t; }
\CommentTok{//With structs, include the keyword 'struct' as part of the original types}
\end{Highlighting}
\end{Shaded}

