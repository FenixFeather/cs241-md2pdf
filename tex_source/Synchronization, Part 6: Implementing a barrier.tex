\subsection{How do I wait for N threads to reach a certain point before
continuing onto the next
step?}\label{how-do-i-wait-for-n-threads-to-reach-a-certain-point-before-continuing-onto-the-next-step}

Suppose we wanted to perform a large multi-threaded calculation that has
two stages but we dont want to advance to the second stage until the
first stage is completed.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double} \NormalTok{data[}\DecValTok{256}\NormalTok{][}\DecValTok{8192}\NormalTok{]}

\DecValTok{1} \NormalTok{Threads }\KeywordTok{do} \NormalTok{first calculation (use and change values in data)}

\DecValTok{2} \NormalTok{Barrier! Wait }\KeywordTok{for} \NormalTok{all threads to finish first calculation before continuing}

\DecValTok{3} \NormalTok{Threads }\KeywordTok{do} \NormalTok{second calculation (use and change values in data)}
\end{Highlighting}
\end{Shaded}

The thread function has four main parts-

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \NormalTok{*calc(}\DataTypeTok{void} \NormalTok{*arg) \{}
  \CommentTok{/* Do my part of the first calculation */}
  \CommentTok{/* Am I the last thread to finish? If so wake up all the other threads! */}
  \CommentTok{/* Otherwise wait until the other threads has finished part one */}
  \CommentTok{/* Do my part of the second calculation */}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Our main thread will create the 16 threads and we will divide each
calculation into 16 separate pieces. Each thread will be given a unique
value (0,1,2,..15), so it can work on its own block.\\Since a
(void\emph{) type can hold small integers, we will pass the value of i
by casting it to a void}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#define N (16)}
\DataTypeTok{double} \NormalTok{data[}\DecValTok{256}\NormalTok{][}\DecValTok{8192}\NormalTok{] ;}
\DataTypeTok{int} \NormalTok{main() \{}
    \NormalTok{pthread_t ids[N];}
    \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < N; i++)  }
        \NormalTok{pthread_create(&ids[i], NULL, calc, (}\DataTypeTok{void} \NormalTok{*) i);}
\end{Highlighting}
\end{Shaded}

Note, we will never dereference this pointer value as an actual memory
location - we will just cast it straight back to an integer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \NormalTok{*calc(}\DataTypeTok{void} \NormalTok{*ptr) \{}
\CommentTok{// Thread 0 will work on columns 0..15, thread 1 on rows 16..31}
  \DataTypeTok{int} \NormalTok{x, y, start = N * (}\DataTypeTok{int}\NormalTok{) ptr;}
  \DataTypeTok{int} \NormalTok{end = start + N; }
  \KeywordTok{for}\NormalTok{(x = start; x < end; x++) }\KeywordTok{for} \NormalTok{(y = }\DecValTok{0}\NormalTok{; y < }\DecValTok{8192}\NormalTok{; y++) \{ }\CommentTok{/* do calc #1 */} \NormalTok{\}}
\end{Highlighting}
\end{Shaded}

After calculation 1 completes we need to wait for the slower threads
(unless we are the last thread!).\\So keep track of the number of
threads that have arrived at our barrier aka `checkpoint':

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Global: }
\DataTypeTok{int} \NormalTok{remain = N;}


\CommentTok{// After calc #1 code:}
\NormalTok{remain--; }\CommentTok{// We finished}
\KeywordTok{if} \NormalTok{(remain ==}\DecValTok{0}\NormalTok{) \{}\CommentTok{/*I'm last!  -  Time for everyone to wake up! */} \NormalTok{\}}
\KeywordTok{else} \NormalTok{\{}
  \KeywordTok{while} \NormalTok{(remain != }\DecValTok{0}\NormalTok{) \{ }\CommentTok{/* spin spin spin*/} \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

However the above code has a race condition (two threads might try to
decrement \texttt{remain}) and the loop is a busy loop. We can do
better! Let's use a condition variable and then we will use a
broadcast/signal functions to wake up the sleeping threads.

A reminder, that a condition variable is similar to a house! Threads go
there to sleep (\texttt{pthread\_cond\_wait}). You can choose to wake up
one thread (\texttt{pthread\_cond\_signal}) or all of them
(\texttt{pthread\_cond\_broadcast}). If there are no threads waiting
inside these calls have no effect.

A condition variable version is usually very similar to a busy loop
incorrect solution. We will need to add a mutex and condition global
variables and to initialize them in \texttt{main} \ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//global variables}
\NormalTok{pthread_mutex_t m;}
\NormalTok{pthread_cond_t cv;}

\NormalTok{main() \{}
  \NormalTok{pthread_mutex_init(&m, NULL);}
  \NormalTok{pthread_cond_init(&cv, NULL);}
\end{Highlighting}
\end{Shaded}

We will use the mutex to ensure that only one thread modifies
\texttt{remain} at a time.\\The last arriving thread needs to wake up
all sleeping threads - so we will need
\texttt{pthread\_cond\_broadcast(\&cv)}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pthread_mutex_lock(&m);}
\NormalTok{remain--; }
\KeywordTok{if} \NormalTok{(remain ==}\DecValTok{0}\NormalTok{) \{ pthread_cond_broadcast(&cv); \}}
\KeywordTok{else} \NormalTok{\{}
  \KeywordTok{while}\NormalTok{(remain != }\DecValTok{0}\NormalTok{) \{ pthread_cond_wait(&cv, &m) \}}
\NormalTok{\}}
\NormalTok{pthread_mutex_unlock(&m);}
\end{Highlighting}
\end{Shaded}

When a thread enters \texttt{pthread\_cond\_wait} it releases the mutex
and sleeps. At some point in the future it will be awoken. Once we bring
a thread back from its sleep, before returning it must wait until it can
lock the mutex. Notice that even if a sleeping thread wakes up early, it
will check the while loop condition and re-enter wait if necessary.
