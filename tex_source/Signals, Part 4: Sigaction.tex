\subsection{\texorpdfstring{How and why do I use \texttt{sigaction}
?}{How and why do I use sigaction ?}}\label{how-and-why-do-i-use-sigaction}

To change the ``signal disposition'' of a process - i.e.~what happens
when a signal is delivered to your process - use \texttt{sigaction}

You can use system call \texttt{sigaction} to set the current handler
for a signal or read the current signal handler for a particular signal.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{sigaction(}\DataTypeTok{int} \NormalTok{signum, }\DataTypeTok{const} \KeywordTok{struct} \NormalTok{sigaction *act, }\KeywordTok{struct} \NormalTok{sigaction *oldact);}
\end{Highlighting}
\end{Shaded}

The sigaction struct includes two callback functions (we will only look
at the `handler' version), a signal mask and a flags field -

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{sigaction \{}
               \DataTypeTok{void}     \NormalTok{(*sa_handler)(}\DataTypeTok{int}\NormalTok{);}
               \DataTypeTok{void}     \NormalTok{(*sa_sigaction)(}\DataTypeTok{int}\NormalTok{, siginfo_t *, }\DataTypeTok{void} \NormalTok{*);}
               \NormalTok{sigset_t   sa_mask;}
               \DataTypeTok{int}        \NormalTok{sa_flags;}
\NormalTok{\}; }
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{How do I convert a \texttt{signal} call into
the equivalent \texttt{sigaction}
call?}{How do I convert a signal call into the equivalent sigaction call?}}\label{how-do-i-convert-a-signal-call-into-the-equivalent-sigaction-call}

Suppose you installed a signal handler for the alarm signal,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{signal(SIGALRM, myhandler);}
\end{Highlighting}
\end{Shaded}

The equivalent \texttt{sigaction} code is:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{sigaction sa; }
\NormalTok{sa.sa_handler = myhandler;}
\NormalTok{sigemptyset(&sa.sa_mask);}
\NormalTok{sa.sa_flags = }\DecValTok{0}\NormalTok{; }
\NormalTok{sigaction(SIGINT, &sa, NULL)}
\end{Highlighting}
\end{Shaded}

However, we typically may also set the mask and the flags field. The
mask is a temporary signal mask used during the signal handler
execution. The SA\_RESTART flag will automatically restart some (but not
all) system calls that otherwise would have returned early (with EINTR
error). The latter means we can simplify the rest of code somewhat
because a restart loop may no longer be required.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sigfillset(&sa.sa_mask);}
\NormalTok{sa.sa_flags = SA_RESTART; }\CommentTok{/* Restart functions if  interrupted by handler */}     
\end{Highlighting}
\end{Shaded}

\subsection{How do I use sigwait?}\label{how-do-i-use-sigwait}

Sigwait can be used to read one pending signal at a time.
\texttt{sigwait} is used to synchronously wait for signals, rather than
handle them in a callback. A typical use of sigwait in a multi-threaded
program is shown below. Notice that the thread signal mask is set first
(and will be inherited by new threads). This prevents signals from being
\emph{delivered} so they will remain in a pending state until sigwait is
called. Also notice the same set sig\_t variable is used by sigwait -
except rather than setting the set of blocked signals it is being used
as the set of signals that sigwait can catch and return.

One advantage of writing a custom signal handling thread (such as the
example below) rather than a callback function is that you can now use
many more C library and system functions that otherwise could not be
safely used in a signal handler because they are not async signal-safe.

Based on
\texttt{http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread\_sigmask.html}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \NormalTok{sigset_t   signal_mask;  }\CommentTok{/* signals to block         */}

\DataTypeTok{int} \NormalTok{main (}\DataTypeTok{int} \NormalTok{argc, }\DataTypeTok{char} \NormalTok{*argv[])}
\NormalTok{\{}
    \NormalTok{pthread_t sig_thr_id;      }\CommentTok{/* signal handler thread ID */}
    \NormalTok{sigemptyset (&signal_mask);}
    \NormalTok{sigaddset (&signal_mask, SIGINT);}
    \NormalTok{sigaddset (&signal_mask, SIGTERM);}
    \NormalTok{pthread_sigmask (SIG_BLOCK, &signal_mask, NULL);}

    \CommentTok{/* New threads will inherit this thread's mask */}
    \NormalTok{pthread_create (&sig_thr_id, NULL, signal_thread, NULL);}

    \CommentTok{/* APPLICATION CODE */}
    \NormalTok{...}
\NormalTok{\}}

\DataTypeTok{void} \NormalTok{*signal_thread (}\DataTypeTok{void} \NormalTok{*arg)}
\NormalTok{\{}
    \DataTypeTok{int}       \NormalTok{sig_caught;    }\CommentTok{/* signal caught       */}

    \CommentTok{/* Use same mask as the set of signals that we'd like to know about! */}
    \NormalTok{sigwait(&signal_mask, &sig_caught);}
    \KeywordTok{switch} \NormalTok{(sig_caught)}
    \NormalTok{\{}
    \KeywordTok{case} \NormalTok{SIGINT:     }\CommentTok{/* process SIGINT  */}
        \NormalTok{...}
        \KeywordTok{break}\NormalTok{;}
    \KeywordTok{case} \NormalTok{SIGTERM:    }\CommentTok{/* process SIGTERM */}
        \NormalTok{...}
        \KeywordTok{break}\NormalTok{;}
    \KeywordTok{default}\NormalTok{:         }\CommentTok{/* should normally not happen */}
        \NormalTok{fprintf (stderr, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Unexpected signal %d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, sig_caught);}
        \KeywordTok{break}\NormalTok{;}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

