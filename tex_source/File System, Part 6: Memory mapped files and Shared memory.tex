\subsection{How does the operating system load my process and libraries
into
memory?}\label{how-does-the-operating-system-load-my-process-and-libraries-into-memory}

By mapping the files' contents into the address-space of the
process.\\If many programs only need read-access to the same file (e.g.
/bin/bash, the C library) then the same physical memory can be shared
between multiple processes.

The same mechanism can be used by programs to directly map files into
memory

\subsection{How do I map a file into
memory?}\label{how-do-i-map-a-file-into-memory}

A simple program to map a file into memory is shown below. The key
points to notice are:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  mmap requires a filedescriptor, so we need to \texttt{open} the file
  first
\item
  We seek to our desired size and write one byte to ensure that the file
  is sufficient length
\item
  When finished call munmap to unmap the file from memory.
\end{itemize}

This example also shows the preprocessor constants ``\textbf{LINE}'' and
``\textbf{FILE}'' that hold the current line number and filename of the
file currently being compiled.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <stdio.h>}
\OtherTok{#include <stdlib.h>}
\OtherTok{#include <sys/types.h>}
\OtherTok{#include <sys/stat.h>}
\OtherTok{#include <sys/mman.h>}
\OtherTok{#include <fcntl.h>}
\OtherTok{#include <unistd.h>}
\OtherTok{#include <errno.h>}
\OtherTok{#include <string.h>}


\DataTypeTok{int} \NormalTok{fail(}\DataTypeTok{char} \NormalTok{*filename, }\DataTypeTok{int} \NormalTok{linenumber) \{ }
  \NormalTok{fprintf(stderr, }\StringTok{"%s:%d %s}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, filename, linenumber, strerror(errno)); }
  \NormalTok{exit(}\DecValTok{1}\NormalTok{);}
  \KeywordTok{return} \DecValTok{0}\NormalTok{; }\CommentTok{/*Make compiler happy */}
\NormalTok{\}}
\OtherTok{#define QUIT fail(__FILE__, __LINE__ )}

\DataTypeTok{int} \NormalTok{main() \{}
  \CommentTok{// We want a file big enough to hold 10 integers  }
  \DataTypeTok{int} \NormalTok{size = }\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{) * }\DecValTok{10}\NormalTok{;}

  \DataTypeTok{int} \NormalTok{fd = open(}\StringTok{"data"}\NormalTok{, O_RDWR | O_CREAT | O_TRUNC, }\DecValTok{0600}\NormalTok{); }\CommentTok{//6 = read+write for me!}

  \NormalTok{lseek(fd, size, SEEK_SET);}
  \NormalTok{write(fd, }\StringTok{"A"}\NormalTok{, }\DecValTok{1}\NormalTok{);}
  
  \DataTypeTok{void} \NormalTok{*addr = mmap(}\DecValTok{0}\NormalTok{, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, }\DecValTok{0}\NormalTok{);}
  \NormalTok{printf(}\StringTok{"Mapped at %p}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, addr);}
  \KeywordTok{if} \NormalTok{(!addr) QUIT;}
  
  \DataTypeTok{int} \NormalTok{*array = addr;}
  \NormalTok{array[}\DecValTok{0}\NormalTok{] = }\BaseNTok{0x12345678}\NormalTok{;}
  \NormalTok{array[}\DecValTok{1}\NormalTok{] = }\BaseNTok{0xdeadc0de}\NormalTok{;}

  \NormalTok{munmap(addr,size);}
  \KeywordTok{return} \DecValTok{0}\NormalTok{;}
  
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The contents of our binary file can be listed using hexdump

\begin{verbatim}
$ hexdump data
0000000 78 56 34 12 de c0 ad de 00 00 00 00 00 00 00 00
0000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000020 00 00 00 00 00 00 00 00 41   
\end{verbatim}

The careful reader may notice that our integers were written in
least-significant-byte format (because that is the endianess of the CPU)
and that we allocated a file that is one byte too many!

The \texttt{PROT\_READ\ \textbar{}\ PROT\_WRITE} options specify the
virtual memory protection. The option \texttt{PROT\_EXEC} (not used
here) can be set to allow CPU execution of instructions in memory
(e.g.~this would be useful if you mapped an executable or library).

\subsection{What are the advantages of memory mapping a
file}\label{what-are-the-advantages-of-memory-mapping-a-file}

For many applications the main advantages are:\\Simplified coding - the
file data is immediately available. No need to parse the incoming data
and store it in new memory structures.\\Sharing of files - memory mapped
files are particularly efficient when the same data is shared between
multiple processes.

Note for simple sequential processing memory mapped files are not
necessarily faster than standard `stream-based' approaches of
\texttt{read} / fscanf etc.

\subsection{How do I share memory between a parent and child
process?}\label{how-do-i-share-memory-between-a-parent-and-child-process}

Easy - Use \texttt{mmap} without a file - just specify the
MAP\_ANONYMOUS and MAP\_SHARED options!

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <stdio.h>}
\OtherTok{#include <stdlib.h>}
\OtherTok{#include <sys/types.h>}
\OtherTok{#include <sys/stat.h>}
\OtherTok{#include <sys/mman.h> }\CommentTok{/* mmap() is defined in this header */}
\OtherTok{#include <fcntl.h>}
\OtherTok{#include <unistd.h>}
\OtherTok{#include <errno.h>}
\OtherTok{#include <string.h>}

\DataTypeTok{int} \NormalTok{main() \{}
  
  \DataTypeTok{int} \NormalTok{size = }\DecValTok{100} \NormalTok{* }\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{);  }
  \DataTypeTok{void} \NormalTok{*addr = mmap(}\DecValTok{0}\NormalTok{, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{);}
  \NormalTok{printf(}\StringTok{"Mapped at %p}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, addr);}
  
  \DataTypeTok{int} \NormalTok{*shared = addr;}
  \NormalTok{pid_t mychild = fork();}
  \KeywordTok{if} \NormalTok{(mychild > }\DecValTok{0}\NormalTok{) \{}
    \NormalTok{shared[}\DecValTok{0}\NormalTok{] = }\DecValTok{10}\NormalTok{;}
    \NormalTok{shared[}\DecValTok{1}\NormalTok{] = }\DecValTok{20}\NormalTok{;}
  \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
    \NormalTok{sleep(}\DecValTok{1}\NormalTok{); }\CommentTok{// We will talk about synchronization later}
    \NormalTok{printf(}\StringTok{"%d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, shared[}\DecValTok{1}\NormalTok{] + shared[}\DecValTok{0}\NormalTok{]);}
  \NormalTok{\}}

  \NormalTok{munmap(addr,size);}
  \KeywordTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Can I use shared memory for IPC
?}\label{can-i-use-shared-memory-for-ipc}

Yes! As a simple example you could reserve just a few bytes and change
the value in shared memory when you want the child process to
quit.\\Sharing memory is a very efficient form of inter-process
communication because there is no copying overhead - the two processes
literally share the same \emph{physical} frame of memory.
