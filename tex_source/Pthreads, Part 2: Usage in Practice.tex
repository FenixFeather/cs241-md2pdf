\subsection{How do I create a pthread?}\label{how-do-i-create-a-pthread}

See
\href{https://github.com/angrave/SystemProgramming/wiki/Pthreads,-Part-1:-Introduction}{Pthreads
Part 1} which introduces \texttt{pthread\_create} and
\texttt{pthread\_join}

\subsection{\texorpdfstring{If I call \texttt{pthread\_create} twice how
many stacks does my process
have?}{If I call pthread\_create twice how many stacks does my process have?}}\label{if-i-call-pthreadux5fcreate-twice-how-many-stacks-does-my-process-have}

Your process will contain three stacks - one for each thread. The first
thread is created when the process starts and you created two more.
Actually there can be more stacks than this but let's ignore that
complication for now. The important idea is that each thread requires a
stack because the stack contains automatic variables and the old CPU PC
register so that it can back to executing the calling function after the
function is finished.

\subsection{What is the difference between a process and a
thread?}\label{what-is-the-difference-between-a-process-and-a-thread}

In addition, unlike processes, threads within the same process can share
the same global memory (data and heap segments).

\subsection{\texorpdfstring{What does \texttt{pthread\_cancel}
do?}{What does pthread\_cancel do?}}\label{what-does-pthreadux5fcancel-do}

Stops a thread. Note the thread may not actually be stopped immediately.
For example it can be terminated when the thread makes an operating
system call (e.g. \texttt{write}).

In practice \texttt{pthread\_cancel} is rarely used because it does not
give a thread an opportunity to clean up after itself (for example, it
may have opened some files).\\An alternative implementation is to use a
boolean (int) variable whose value is used to inform other threads that
they should finish and clean up.

\subsection{\texorpdfstring{What is the difference between \texttt{exit}
and
\texttt{pthread\_exit}?}{What is the difference between exit and pthread\_exit?}}\label{what-is-the-difference-between-exit-and-pthreadux5fexit}

\texttt{exit(42)} exits the entire process and sets the processes exit
value. This is equivalent to \texttt{return\ 42} in the main method. All
threads inside the process are stopped.

\texttt{pthread\_exit(void\ *)} only stops the calling thread i.e.~the
thread never returns after calling \texttt{pthread\_exit}. The pthread
library will automatically finish the process if there are no other
threads running. \texttt{pthread\_exit(...)} is equivalent to returning
from the thread's function; both finish the thread and also set the
return value (void *pointer) for the thread.

Calling \texttt{pthread\_exit} in the the \texttt{main} thread is a
common way for simple programs to ensure that all threads finish. For
example, in the following program, the \texttt{myfunc} threads will
probably not have time to get started.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{main() \{}
  \NormalTok{pthread_t tid1, tid2;}
  \NormalTok{pthread_create(&tid1, NULL, myfunc, }\StringTok{"Jabberwocky"}\NormalTok{);}
  \NormalTok{pthread_create(&tid2, NULL, myfunc, }\StringTok{"Vorpel"}\NormalTok{);}
  \NormalTok{exit(}\DecValTok{42}\NormalTok{); }\CommentTok{//or return 42;}

  \CommentTok{// No code is run after exit}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The next two programs will wait for the new threads to finish-

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{main() \{}
  \NormalTok{pthread_t tid1, tid2;}
  \NormalTok{pthread_create(&tid1, NULL, myfunc, }\StringTok{"Jabberwocky"}\NormalTok{);}
  \NormalTok{pthread_create(&tid2, NULL, myfunc, }\StringTok{"Vorpel"}\NormalTok{);}
  \NormalTok{pthread_exit(NULL); }

  \CommentTok{// No code is run after pthread_exit}
  \CommentTok{// However process will continue to exist until both threads have finished}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Alternatively, we join on each thread (i.e.~wait for it to finish)
before we return from main (or call exit).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{main() \{}
  \NormalTok{pthread_t tid1, tid2;}
  \NormalTok{pthread_create(&tid1, NULL, myfunc, }\StringTok{"Jabberwocky"}\NormalTok{);}
  \NormalTok{pthread_create(&tid2, NULL, myfunc, }\StringTok{"Vorpel"}\NormalTok{);}
  \CommentTok{// wait for both threads to finish :}
  \DataTypeTok{void}\NormalTok{* result;}
  \NormalTok{pthread_join(tid1, &result);}
  \NormalTok{pthread_join(tid2, &result); }
  \KeywordTok{return} \DecValTok{42}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note the pthread\_exit version creates thread zombies, however this is
not a long-running processes, so we don't care.

\subsection{How can a thread can be
terminated?}\label{how-can-a-thread-can-be-terminated}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Returning from the thread function
\item
  Calling \texttt{pthread\_exit}
\item
  Cancelling the thread with \texttt{pthread\_cancel}
\item
  Terminating the process (e.g.~SIGTERM); exit(); returning from
  \texttt{main}
\end{itemize}

\subsection{What is the purpose of
pthread\_join?}\label{what-is-the-purpose-of-pthreadux5fjoin}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Wait for a thread to finish
\item
  Clean up thread resources.
\end{itemize}

\subsection{\texorpdfstring{What happens if you don't call
\texttt{pthread\_join}?}{What happens if you don't call pthread\_join?}}\label{what-happens-if-you-dont-call-pthreadux5fjoin}

Finished threads will continue to consume resources. Eventually, if
enough threads are created, \texttt{pthread\_create} will fail.\\In
practice, this is only an issue for long-runnning processes but is not
an issue for simple, short-lived processes as all thread resources are
automatically freed when the process exits.

\subsection{\texorpdfstring{Should I use \texttt{pthread\_exit} or
\texttt{pthread\_join}?}{Should I use pthread\_exit or pthread\_join?}}\label{should-i-use-pthreadux5fexit-or-pthreadux5fjoin}

Both \texttt{pthread\_exit} and \texttt{pthread\_join} will let the
other threads finish on their own (even if called in the main thread).
However, only \texttt{pthread\_join} will return to you when the
specified thread finishes. \texttt{pthread\_exit} does not wait and will
immediately end your thread and give you no chance to continue
executing.

\subsection{Can you pass pointers to stack variables from one thread to
another?}\label{can-you-pass-pointers-to-stack-variables-from-one-thread-to-another}

Yes. However you need to be very careful about the lifetime of stack
variables.

\begin{verbatim}
pthread start_threads() {
  int start = 42;
  pthread_t tid;
  pthread_create(&tid, 0, myfunc, &start); // ERROR!
  return tid;
}
\end{verbatim}

The above code is invalid because the function \texttt{start\_threads}
will likely return before \texttt{myfunc} even starts. The function
passes the address-of \texttt{start}, however by the time
\texttt{myfunc} is executes, \texttt{start} is no longer in scope and
its address will re-used for another variable.

The following code is valid because the lifetime of the stack variable
is longer than the background thread.

\begin{verbatim}
void start_threads() {
  int start = 42;
  void *result;
  pthread_t tid;
  pthread_create(&tid, 0, myfunc, &start); // OK - start will be valid!
  pthread_join(tid, &result);
}
\end{verbatim}

\subsection{How can I create ten threads with different starting
values.}\label{how-can-i-create-ten-threads-with-different-starting-values.}

The following code is supposed to start ten threads with values
0,1,2,3,\ldots{}9\\However, when run prints out
\texttt{1\ 7\ 8\ 8\ 8\ 8\ 8\ 8\ 8\ 10}! Can you see why?

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <pthread.h>}
\DataTypeTok{void}\NormalTok{* myfunc(}\DataTypeTok{void}\NormalTok{* ptr) \{}
    \DataTypeTok{int} \NormalTok{i = *((}\DataTypeTok{int} \NormalTok{*) ptr);}
    \NormalTok{printf(}\StringTok{"%d "}\NormalTok{, i);}
    \KeywordTok{return} \NormalTok{NULL;}
\NormalTok{\}}

\DataTypeTok{int} \NormalTok{main() \{}
    \CommentTok{// Each thread gets a different value of i to process}
    \DataTypeTok{int} \NormalTok{i;}
    \NormalTok{pthread_t tid;}
    \KeywordTok{for}\NormalTok{(i =}\DecValTok{0}\NormalTok{; i < }\DecValTok{10}\NormalTok{; i++) \{}
        \NormalTok{pthread_create(&tid, NULL, myfunc, &i); }\CommentTok{// ERROR}
    \NormalTok{\}}
    \NormalTok{pthread_exit(NULL);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The above code suffers from a \texttt{race\ condition} - the value of i
is changing. The new threads start later (in the example output the last
thread starts after the loop has finished).

To overcome this race-condition, we will give each thread a pointer to
it's own data area. For example, for each thread we may want to store
the id, a starting value and an output value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{T \{}
  \NormalTok{thread_t id;}
  \DataTypeTok{int} \NormalTok{start;}
  \DataTypeTok{char} \NormalTok{result[}\DecValTok{100}\NormalTok{];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

These can be stored in an array -

\begin{verbatim}
struct T *info = calloc(10 , sizeof(struct T)); // reserve enough bytes for ten T structures
\end{verbatim}

And each array element passed to each thread -

\begin{verbatim}
pthread_create(&info[i].id, NULL, func, &info[i]);
\end{verbatim}

\subsection{Why are some functions e.g. asctime,getenv, strtok, strerror
not
thread-safe?}\label{why-are-some-functions-e.g.-asctimegetenv-strtok-strerror-not-thread-safe}

To answer this, let's look at a simple function that is also not
`thread-safe'

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \NormalTok{*to_message(}\DataTypeTok{int} \NormalTok{num) \{}
    \DataTypeTok{char} \DataTypeTok{static} \NormalTok{result [}\DecValTok{256}\NormalTok{];}
    \KeywordTok{if} \NormalTok{(num < }\DecValTok{10}\NormalTok{) sprintf(result, }\StringTok{"%d : blah blah"} \NormalTok{, num);}
    \KeywordTok{else} \NormalTok{strcpy(result, }\StringTok{"Unknown"}\NormalTok{);}
    \KeywordTok{return} \NormalTok{result;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In the above code the result buffer is stored in global memory. This is
good - we wouldn't want to return a pointer to an invalid address on the
stack, but there's only one result buffer in the entire memory. If two
threads were to use it at the same time then one would corrupt the
other:

\begin{longtable}[c]{@{}llll@{}}
\toprule
Time & Thread 1 & Thread 2 & Comments\tabularnewline
\midrule
\endhead
1 & to\_m(5 ) &\tabularnewline
2 & & to\_m(99) & Now both threads will see ``Unknown'' stored in the
result buffer\tabularnewline
\bottomrule
\end{longtable}

\subsection{What are condition variables, semaphores,
mutexes?}\label{what-are-condition-variables-semaphores-mutexes}

These are synchronization locks that are used to prevent race conditions
and ensure proper synchronization between threads running in the same
program. In addition these locks are conceptually identical to the
primitives used inside the kernel.

\subsection{Are there any advantages of using threads over forking
processes?}\label{are-there-any-advantages-of-using-threads-over-forking-processes}

Yes! Sharing information between threads is easy because threads (of the
same process) live inside the same virtual memory space.\\Also, creating
a thread is significantly faster than creating(forking) a process.

\subsection{Are there any dis-advantages of using threads over forking
processes?}\label{are-there-any-dis-advantages-of-using-threads-over-forking-processes}

Yes! No- isolation! As threads live inside the same process, one thread
has access to the same virtual memory as the other threads. A single
thread can terminate the entire process (e.g.~by trying to read address
zero).

\subsection{Can you fork a process with multiple
threads?}\label{can-you-fork-a-process-with-multiple-threads}

Yes! However the child process only has a single thread (which is a
clone of the thread that called \texttt{fork}. We can see this as a
simple example, where the background threads never print out a second
message in the child process.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <pthread.h>}
\OtherTok{#include <stdio.h>}
\OtherTok{#include <unistd.h>}

\DataTypeTok{static} \NormalTok{pid_t child = -}\DecValTok{2}\NormalTok{;}

\DataTypeTok{void} \NormalTok{*sleepnprint(}\DataTypeTok{void} \NormalTok{*arg) \{}
  \NormalTok{printf(}\StringTok{"%d:%s starting up...}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, getpid(), (}\DataTypeTok{char} \NormalTok{*) arg);}

  \KeywordTok{while} \NormalTok{(child == -}\DecValTok{2}\NormalTok{) \{sleep(}\DecValTok{1}\NormalTok{);\} }\CommentTok{/* Later we will use condition variables */}

  \NormalTok{printf(}\StringTok{"%d:%s finishing...}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,getpid(), (}\DataTypeTok{char}\NormalTok{*)arg);}

  \KeywordTok{return} \NormalTok{NULL;  }
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{main() \{}
  \NormalTok{pthread_t tid1, tid2;}
  \NormalTok{pthread_create(&tid1,NULL, sleepnprint, }\StringTok{"New Thread One"}\NormalTok{);}
  \NormalTok{pthread_create(&tid2,NULL, sleepnprint, }\StringTok{"New Thread Two"}\NormalTok{);}
  
  \NormalTok{child = fork();}
  \NormalTok{printf(}\StringTok{"%d:%s}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,getpid(), }\StringTok{"fork()ing complete"}\NormalTok{);}
  \NormalTok{sleep(}\DecValTok{3}\NormalTok{);}
    
  \NormalTok{printf(}\StringTok{"%d:%s}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,getpid(), }\StringTok{"Main thread finished"}\NormalTok{);}
  
  \NormalTok{pthread_exit(NULL);}
  \KeywordTok{return} \DecValTok{0}\NormalTok{; }\CommentTok{/* Never executes */}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
8970:New Thread One starting up...
8970:fork()ing complete
8973:fork()ing complete
8970:New Thread Two starting up...
8970:New Thread Two finishing...
8970:New Thread One finishing...
8970:Main thread finished
8973:Main thread finished
\end{verbatim}

In practice creating threads before forking can lead to unexpected
errors because (as demonstrated above) the other threads are immediately
terminated when forking. Another thread might have just lock a mutex
(e.g.~by calling malloc) and never unlock it again. Advanced users may
find \texttt{pthread\_atfork} useful however we suggest you usually try
to avoid creating threads before forking unless you fully understand the
limitations and difficulties of this approach.

\subsection{\texorpdfstring{Are there other reasons where \texttt{fork}
might be preferable to creating a
thread.}{Are there other reasons where fork might be preferable to creating a thread.}}\label{are-there-other-reasons-where-fork-might-be-preferable-to-creating-a-thread.}

Creating separate processes is useful

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  When more security is desired (for example, Chrome browser uses
  different processes for different tabs)
\item
  When running an existing and complete program then a new process is
  required (e.g.~starting `gcc')
\end{itemize}

\subsection{How can I find out more?}\label{how-can-i-find-out-more}

See the complete example in the man page
-\\{[}{[}\url{http://man7.org/linux/man-pages/man3/pthread_create.3.html}{]}{]}\\And
the pthread reference guide -\\{[}{[}pthread guide\textbar{}
\url{http://man7.org/linux/man-pages/man7/pthreads.7.html}{]}{]}\\ALSO:
Concise third party sample code explaining create, join and exit
-\\{[}{[}\url{http://www.thegeekstuff.com/2012/04/terminate-c-thread/}{]}{]}
