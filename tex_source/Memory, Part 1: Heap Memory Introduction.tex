\chapter{Memory} happens when I call
malloc?}\label{what-happens-when-i-call-malloc}

The function \texttt{malloc} is a C library call and is used to reserve
a contiguous block of memory. Unlike stack memory, the memory remains
allocated until \texttt{free} is called with the same pointer. There is
also \texttt{calloc} and \texttt{realloc} which are discussed below.

\subsection{Can malloc fail?}\label{can-malloc-fail}

If \texttt{malloc} fails to reserve any more memory then it returns
\texttt{NULL}. Robust programs should check the return value. If your
code assumes \texttt{malloc} succeeds and it does not, then your program
will likely crash (segfault) when it tries to write to address 0.

\subsection{Where is the heap and how big is
it?}\label{where-is-the-heap-and-how-big-is-it}

The heap is part of the process memory and it does not have a fixed
size. Heap memory allocation is performed by the C library when you call
\texttt{malloc} (\texttt{calloc}, \texttt{realloc}) and \texttt{free}.

First a quick review on process memory: A process is a running instance
of your program. Each program has it's own address space. For example on
a 32 bit machine your process gets about 4 billion addresses to play
with, however not all of these are valid or even mapped to actual
physical memory (RAM). Inside the process's memory you will find the
executable code, space for the stack, environment variables, global
(static) variables and the heap.

By calling \texttt{sbrk} the C library can increase the size of the heap
as your program demands more heap memory. As the heap and stack (one for
each thread) need to grow, we put them at opposite ends of the address
space. So for typical architectures the heap will grows upwards and the
stack grows downwards. If we write a multi-threaded program (more about
that later) we will need multiple stacks (one per thread) but there's
only ever one heap.

On typical architectures, the heap is part of the \texttt{Data\ segment}
and starts just above the code and global variables.

\subsection{Do programs need to call brk or
sbrk?}\label{do-programs-need-to-call-brk-or-sbrk}

Not typically (though calling \texttt{sbrk(0)} can be interesting
because it tells you where your heap currently ends). Instead programs
use \texttt{malloc,calloc,realloc} and \texttt{free} which are part of
the C library. The internal implementation of these functions will call
\texttt{sbrk} when additional heap memory is required.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \NormalTok{*top_of_heap = sbrk(}\DecValTok{0}\NormalTok{);}
\NormalTok{malloc(}\DecValTok{16384}\NormalTok{);}
\DataTypeTok{void} \NormalTok{*top_of_heap2 = sbrk(}\DecValTok{0}\NormalTok{);}
\NormalTok{printf(}\StringTok{"The top of heap went from %p to %p }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, top_of_heap, top_of_heap2);}
\end{Highlighting}
\end{Shaded}

Example output:
\texttt{The\ top\ of\ heap\ went\ from\ 0x4000\ to\ 0xa000}

\subsection{What is calloc?}\label{what-is-calloc}

Unlike \texttt{malloc}, \texttt{calloc} initializes memory contents to
zero and also takes two arguments (the number of items and the size in
bytes of each item). A naive but readable implementation of
\texttt{calloc} looks like this-

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \NormalTok{*calloc(size_t n, size_t size)}
\NormalTok{\{}
    \NormalTok{size_t total = n * size; }\CommentTok{// Does not check for overflow!}
    \DataTypeTok{void} \NormalTok{*result = malloc(total);}
    
    \KeywordTok{if} \NormalTok{(!result) }\KeywordTok{return} \NormalTok{NULL;}
    
\CommentTok{// If we're using new memory pages }
\CommentTok{// just allocated from the system by calling sbrk}
\CommentTok{// then they will be zero so zero-ing out is unnecessary,}

    \NormalTok{memset(result, }\DecValTok{0}\NormalTok{, total);}
    \KeywordTok{return} \NormalTok{result; }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

An advanced discussion of these limitations is
{[}{[}here\textbar{}\url{http://locklessinc.com/articles/calloc/}{]}{]}

Programmers often use \texttt{calloc} rather than explicitly calling
\texttt{memset} after \texttt{malloc}, to set the memory contents to
zero. Note \texttt{calloc(x,y)} is identical to \texttt{calloc(y,x)},
but you should follow the conventions of the manual.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Ensure our memory is initialized to zero}
\NormalTok{link_t *link  = malloc(}\DecValTok{256}\NormalTok{);}
\NormalTok{memset(link, }\DecValTok{0}\NormalTok{, }\DecValTok{256}\NormalTok{); }\CommentTok{// Assumes malloc returned a valid address!}

\NormalTok{link_t *link = calloc(}\DecValTok{1}\NormalTok{, }\DecValTok{256}\NormalTok{); }\CommentTok{// safer: calloc(1, sizeof(link_t));}
\end{Highlighting}
\end{Shaded}

\subsection{Why is the memory that is first returned by sbrk initialized
to
zero?}\label{why-is-the-memory-that-is-first-returned-by-sbrk-initialized-to-zero}

If the operating system did not zero out contents of physical RAM it
might be possible for one process to learn about the memory of another
process that had previously used the memory. This would be a security
leak.

Unfortunately this means that for \texttt{malloc} requests before any
memory has been freed and simple programs (which end up using newly
reserved memory from the system) the memory is \emph{often} zero. Then
programmers mistaken write C programs that assume malloc'd memory will
\emph{always} be zero.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{* ptr = malloc(}\DecValTok{300}\NormalTok{);}
\CommentTok{// contents is probably zero because we get brand new memory}
\CommentTok{// so beginner programs appear to work!}
\CommentTok{// strcpy(ptr, "Some data); // work with the data}
\NormalTok{free(ptr);}
\CommentTok{// later}
\DataTypeTok{char} \NormalTok{*ptr2 = malloc(}\DecValTok{308}\NormalTok{); }\CommentTok{// Contents might now contain existing data and is probably not zero}
\end{Highlighting}
\end{Shaded}

\subsection{Why doesn't malloc always initialize memory to
zero?}\label{why-doesnt-malloc-always-initialize-memory-to-zero}

Performance! We want malloc to be as fast as possible. Zeroing out
memory may be unnecessary.

\subsection{What is realloc and when would you use
it?}\label{what-is-realloc-and-when-would-you-use-it}

\texttt{realloc} allows you to resize an existing memory allocation that
was previously allocated on the heap (via malloc,calloc or realloc). The
most common use of realloc is to resize memory used to hold an array of
values.A naive but readable version of realloc is suggested below

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \NormalTok{* realloc(}\DataTypeTok{void} \NormalTok{* ptr, size_t newsize) \{}
  \CommentTok{// Simple implementation always reserves more memory}
  \CommentTok{// and has no error checking}
  \DataTypeTok{void} \NormalTok{*result = malloc(newsize); }
  \NormalTok{size_t oldsize =  ... }\CommentTok{//(depends on allocator's internal data structure)}
  \KeywordTok{if} \NormalTok{(ptr) memcpy(result, ptr, oldsize);}
  \NormalTok{free(ptr);}
  \KeywordTok{return} \NormalTok{result;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

An INCORRECT use of realloc is shown below:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{*array = malloc(}\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{) * }\DecValTok{2}\NormalTok{);}
\NormalTok{array[}\DecValTok{0}\NormalTok{] = }\DecValTok{10}\NormalTok{; array[}\DecValTok{1}\NormalTok{]; = }\DecValTok{20}\NormalTok{;}
\CommentTok{// Ooops need a bigger array - so use realloc..}
\NormalTok{realloc (array, }\DecValTok{3}\NormalTok{); }\CommentTok{// ERRORS!}
\NormalTok{array[}\DecValTok{2}\NormalTok{] = }\DecValTok{30}\NormalTok{; }
\end{Highlighting}
\end{Shaded}

The above code contains two mistakes. Firstly we needed 3*sizeof(int)
bytes not 3 bytes.\\Secondly realloc may need to move the existing
contents of the memory to a new location. For example, there may not be
sufficient space because the neighboring bytes are already allocated. A
correct use of realloc is shown below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{array = realloc(array, }\DecValTok{3} \NormalTok{* }\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{));}
\CommentTok{// If array is copied to a new location then old allocation will be freed.}
\end{Highlighting}
\end{Shaded}

A robust version would also check for a \texttt{NULL} return value. Note
\texttt{realloc} can be used to grow and shrink allocations.

\subsection{Where can I read more?}\label{where-can-i-read-more}

See the man page!
{[}{[}\url{http://man7.org/linux/man-pages/man3/malloc.3.html}{]}{]}

\subsection{How important is that memory allocation is
fast?}\label{how-important-is-that-memory-allocation-is-fast}

Very! Allocating and de-allocating heap memory is a common operation in
most applications.

\subsection{What is the silliest malloc and free implementation and what
is wrong with
it?}\label{what-is-the-silliest-malloc-and-free-implementation-and-what-is-wrong-with-it}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{* malloc(size_t size)}
\CommentTok{// Ask the system for more bytes by extending the heap space. }
\CommentTok{// sbrk Returns -1 on failure}
   \DataTypeTok{void} \NormalTok{*p = sbrk(size); }
   \KeywordTok{if}\NormalTok{(p == (}\DataTypeTok{void} \NormalTok{*) -}\DecValTok{1}\NormalTok{) }\KeywordTok{return} \NormalTok{NULL; }\CommentTok{// No space left}
   \KeywordTok{return} \NormalTok{p;}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{free() \{}\CommentTok{/* Do nothing */}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The above implementation suffers from two major drawbacks:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  System calls are slow (compared to library calls). We should reserve a
  large amount of memory and only occasionally ask for more from the
  system.
\item
  No reuse of freed memory. Our program never re-uses heap memory - it
  just keeps asking for a bigger heap.
\end{itemize}

If this allocator was used in a typical program, the process would
quickly exhaust all available memory.\\Instead we need an allocator that
can efficiently use heap space and only ask for more memory when
necessary.

\subsection{What are placement
strategies?}\label{what-are-placement-strategies}

During program execution memory is allocated ande de-allocated (freed),
so there will be gaps (holes) in the heap memory that can be re-used for
future memory requests. The memory allocator needs to keep track of
which parts of the heap are currently allocated and which are parts are
available.

Suppose our current heap size is 64K, though not all of it is in use
because some earlier malloc'd memory has already been freed by the
program-

16KB free \textbar{} 10KB allocated \textbar{} 1KB free \textbar{} 1KB
allocated \textbar{} 30KB free \textbar{} 4KB allocated \textbar{} 2KB
free\\---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---

If a new malloc request for 2KB is executed (\texttt{malloc(2048)}),
where should \texttt{malloc} reserve the memory? It could use the last
2KB hole (which happens to be the perfect size!) or it could split one
of the other two free holes. These choices represent different placement
strategies.

Whichever hole is chosen, the allocator will need to split the hole into
two: The newly allocated space (which will be returned to the program)
and a smaller hole (if there is spare space left over).

A perfect-fit strategy finds the smallest hole that is of sufficient
size (at least 2KB):

16KB free \textbar{} 10KB allocated \textbar{} 1KB free \textbar{} 1KB
allocated \textbar{} 30KB free \textbar{} 4KB allocated \textbar{}
\texttt{2KB\ HERE!}\\---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---

A worst-fit strategy finds the largest hole that is of sufficient size
(so break the 30KB hole into two):

16KB free \textbar{} 10KB allocated \textbar{} 1KB free \textbar{} 1KB
allocated \textbar{} \texttt{2KB\ HERE!} \textbar{} \texttt{28KB\ free}
\textbar{} 4KB allocated \textbar{} 2KB
free\\---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---

A first-fit strategy finds the first available hole that is of
sufficient size (break the 16KB hole into two):

\texttt{2KB\ HERE!} \textbar{} \texttt{14KB\ free} \textbar{} 10KB
allocated \textbar{} 1KB free \textbar{} 1KB allocated \textbar{} 30KB
free \textbar{} 4KB allocated \textbar{} 2KB
free\\---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---

\subsection{What is fragmentation?}\label{what-is-fragmentation}

In the example below, of the 64KB of heap memory, 17KB is allocated, and
47KB is free. However the largest available block is only 30KB because
our available unallocated heap memory is fragmented into smaller pieces.

\texttt{16KB\ free} \textbar{} 10KB allocated \textbar{} 1KB free
\textbar{} 1KB allocated \textbar{} 30KB free \textbar{} 4KB allocated
\textbar{} 2KB
free\\---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---\textbar{}---

\subsection{What effect do placement strategies have on fragmentation
and
performance?}\label{what-effect-do-placement-strategies-have-on-fragmentation-and-performance}

Different strategies affect the fragmentation of heap memory in
non-obvious ways, which only are discovered by mathematical analysis or
careful simulations under real-world conditions (for example simulating
the memory allocation requests of a database or webserver).\\For
example, best-fit at first glance appears to be an excellent strategy
however, if we can not find a perfectly-sized hole then this placement
creates many tiny unusable holes, leading to high fragmentation. It also
requires a scan of all possible holes.

First fit has the advantage that it will not evaluate all possible
placements and therefore be faster.

Since Worst-fit targets the largest unallocated space, it is a poor
choice if large allocations are required.

In practice first-fit and next-fit (which is not discussed here) are
often common placement strategy. Hybrid approaches and many other
alternatives exist (see implementing a memory allocator page).

\subsection{What are the challenges of writing a heap
allocator?}\label{what-are-the-challenges-of-writing-a-heap-allocator}

The main challenges are,

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Need to minimize fragmentation (i.e.~maximize memory utilization)
\item
  Need high performance
\item
  Fiddly implementation (lots of pointer manipulation using linked lists
  and pointer arithmetic)
\end{itemize}

Some additional comments:

Both fragmentation and performance depend on the application allocation
profile, which can be evaluated but not predicted and in practice,
under-specific usage conditions, a special-purpose allocator can often
out-perform a general purpose implementation.

The allocator doesn't know the program's memory allocation requests in
advance. Even if we did, this is the
\href{http://en.wikipedia.org/wiki/Knapsack_problem}{Knapsack problem}
which is known to be NP hard!

\subsection{How do you implement a memory
allocator?}\label{how-do-you-implement-a-memory-allocator}

Good question.
\href{https://github.com/angrave/SystemProgramming/wiki/Memory\%2C-Part-2\%3A-Implementing-a-Memory-Allocator}{Implementing
a memory allocator}
