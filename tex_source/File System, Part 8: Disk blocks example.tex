\subsection{Under construction}\label{under-construction}

\subsection{Please can you explain a simple model of how the file's
content is stored in a simple i-node based
filesystem?}\label{please-can-you-explain-a-simple-model-of-how-the-files-content-is-stored-in-a-simple-i-node-based-filesystem}

Sure!To answer this question we'll build a virtual disk and then write
some C code to access its contents. Our filesystem will divide the bytes
available into space for inodes and a much larger space for disk blocks.
Each disk block will be 4096 bytes-

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Disk size:}
\OtherTok{#define MAX_INODE (1024)}
\OtherTok{#define MAX_BLOCK (1024*1024)}

\CommentTok{// Each block is 4096 bytes:}
\KeywordTok{typedef} \DataTypeTok{char}\NormalTok{[}\DecValTok{4096}\NormalTok{] block_t;}

\CommentTok{// A disk is an array of inodes and an array of disk blocks:}
\KeywordTok{struct} \NormalTok{inode[MAX_INODE] inodes;}
\NormalTok{block[MAX_BLOCK] blocks;}
\end{Highlighting}
\end{Shaded}

Note for clarity we will not use `unsigned' in this code example. Our
fixed-sized inodes will contain the file's size in bytes,
permission,user,group information, time meta-data. What is most relevant
to the problem-at hand is that it will also include ten pointers to disk
blocks that we will use to refer to the actual file's contents!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{inode \{}
 \DataTypeTok{int}\NormalTok{[}\DecValTok{10}\NormalTok{] directblocks; }\CommentTok{// indices for the block array i.e. where to the find the file's content}
 \DataTypeTok{long} \NormalTok{size;}
 \CommentTok{// ... standard inode meta-data e.g.}
 \DataTypeTok{int} \NormalTok{mode, userid,groupid;}
 \NormalTok{time_t ctime,atime,mtime;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now we can work out how to read a byte at offset \texttt{position} of
our file:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \NormalTok{readbyte(inode*inode,}\DataTypeTok{long} \NormalTok{position) \{}
  \KeywordTok{if}\NormalTok{(position <}\DecValTok{0} \NormalTok{|| position >= inode->size) }\KeywordTok{return} \NormalTok{-}\DecValTok{1}\NormalTok{; }\CommentTok{// invalid offset}

  \DataTypeTok{int}  \NormalTok{block_count = position / }\DecValTok{4096}\NormalTok{,offset = position % }\DecValTok{4096}\NormalTok{;}
  
  \CommentTok{// block count better be 0..9 !}
  \DataTypeTok{int} \NormalTok{physical_idx = lookup_physical_block_index(inode, block_count );}

  \CommentTok{// sanity check that the disk block index is reasonable...}
  \NormalTok{assert(physical_idx >=}\DecValTok{0} \NormalTok{&& physical_idx < MAX_BLOCK);}


  \CommentTok{// read the disk block from our virtual disk 'blocks' and return the specific byte}
  \KeywordTok{return} \NormalTok{blocks[physical_idx][offset];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Our initial version of lookup\_physical\_block is simple - we can use
our table of 10 direct blocks!

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{lookup_physical_block_index(inode*inode, }\DataTypeTok{int} \NormalTok{block_count) \{}
  \NormalTok{assert(block_count>=}\DecValTok{0} \NormalTok{&& block_count < }\DecValTok{10}\NormalTok{);}

  \KeywordTok{return} \NormalTok{inode->directblocks[ block_count ]; }\CommentTok{// returns an index value between [0,MAX_BLOCK)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This simple representation is reasonable provided we can represent all
possible files with just ten blocks i.e.~upto 40KB. What about larger
files? We need the inode struct to always be the same size so just
increasing the existing direct block array to 20 would roughly double
the size of our inodes. If most of our files require less than 10
blocks, then our inode storage is now wasteful. To solve this problem we
will use a disk block calledn the \emph{indirect block} to extend the
array of pointers at our disposal. We will only need this for files
\textgreater{} 40KB

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{inode \{}
 \DataTypeTok{int}\NormalTok{[}\DecValTok{10}\NormalTok{] directblocks; }\CommentTok{// if size<4KB then only the first one is valid}
 \DataTypeTok{int} \NormalTok{indirectblock; }\CommentTok{// valid value when size >= 40KB}
 \DataTypeTok{int} \NormalTok{size;}
 \NormalTok{...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The indirect block is just a regular disk block of 4096 bytes but we
will use it to hold pointers to disk blocks. Our pointers in this case
are just integers, so we need to cast the pointer to an integer pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{lookup_physical_block_index(inode*inode, }\DataTypeTok{int} \NormalTok{block_count) \{}
  \NormalTok{assert(}\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{)==}\DecValTok{4}\NormalTok{); }\CommentTok{// Warning this code assumes an index is 4 bytes!}
  \NormalTok{assert(block_count>=}\DecValTok{0} \NormalTok{&& block_count < }\DecValTok{1024} \NormalTok{+ }\DecValTok{10}\NormalTok{); }\CommentTok{// 0 <= block_count< 1034}

  \KeywordTok{if}\NormalTok{( block_count < }\DecValTok{10}\NormalTok{)}
     \KeywordTok{return} \NormalTok{inode->directblocks[ block_count ];}
  
  \CommentTok{// read the indirect block from disk:}
  \NormalTok{block_t* oneblock = & blocks[ inode->indirectblock ];}

  \CommentTok{// Treat the 4KB as an array of 1024 pointers to other disk blocks}
  \DataTypeTok{int}\NormalTok{* table = (}\DataTypeTok{int}\NormalTok{*) oneblock;}
  
 \CommentTok{// Look up the correct entry in the table}
 \CommentTok{// Offset by 10 because the first 10 blocks of data are already }
 \CommentTok{// accounted for}
  \KeywordTok{return} \NormalTok{table[ block_count - }\DecValTok{10} \NormalTok{];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For a typical filesystem our index values are 32 bits i.e.~4bytes. Thus
in 4096 bytes we can store 4096 / 4 = 1024 entries\\This means our
indirect block can refer to 1024 * 4KB = 4MB of data. With the first ten
direct blocks we can therefore accommodate files up to 40KB + 1024 *
4KB= 4136KB . Some of the later table entries can be invalid for files
that are smaller than this.

For even larger files we could use two indirect blocks. However there's
a better alternative, that will allow us to efficiently scale up to huge
files. We will include a double-indirect pointer and if that's not
enough a triple indirect pointer. The double indirect pointer means we
have a table of 1024 entries to disk blocks that are used as 1024
entries. This means we can refer to 1024*1024 disk blocks of data.

\includegraphics{http://uw714doc.sco.com/en/FS_admin/graphics/s5chain.gif}

(source: \url{http://uw714doc.sco.com/en/FS_admin/graphics/s5chain.gif})

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{lookup_physical_block_index(inode*inode, }\DataTypeTok{int} \NormalTok{block_count) \{}
  \KeywordTok{if}\NormalTok{( block_count < }\DecValTok{10}\NormalTok{)}
     \KeywordTok{return} \NormalTok{inode->directblocks[ block_count ];}

  \CommentTok{// Use indirect block for the next 1024 blocks:}
  \CommentTok{// Assumes 1024 ints can fit inside each block!}
  \KeywordTok{if}\NormalTok{( block_count < }\DecValTok{1024} \NormalTok{+ }\DecValTok{10}\NormalTok{) \{   }
      \DataTypeTok{int}\NormalTok{* table = (}\DataTypeTok{int}\NormalTok{*) & blocks[ inode->indirectblock ];}
      \KeywordTok{return} \NormalTok{table[ block_count - }\DecValTok{10} \NormalTok{];}
  \NormalTok{\}}
  \CommentTok{// For huge files we will use a table of tables}
  \DataTypeTok{int} \NormalTok{i = (block_count - }\DecValTok{1034}\NormalTok{) / }\DecValTok{1024} \NormalTok{, j = (block_count - }\DecValTok{1034}\NormalTok{) % }\DecValTok{1024}\NormalTok{;}
  \NormalTok{assert(i<}\DecValTok{1024}\NormalTok{); }\CommentTok{// triple-indirect is not implemented here!}

  \DataTypeTok{int}\NormalTok{* table1 = (}\DataTypeTok{int}\NormalTok{*) & blocks[ inode->doubleindirectblock ];}
   \CommentTok{// The first table tells us where to read the second table ...}
  \DataTypeTok{int}\NormalTok{* table2 = (}\DataTypeTok{int}\NormalTok{*) & blocks[   table1[i]   ];}
  \KeywordTok{return} \NormalTok{table2[j];}
 
   \CommentTok{// For gigantic files we will need to implement triple-indirect (table of tables of tables)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice that reading a byte using double indirect requires 3 disk block
reads (two tables and the actual data block).
