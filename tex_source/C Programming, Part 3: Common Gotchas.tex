What common mistakes do C programmers make?

\section{Memory mistakes}\label{memory-mistakes}

\subsection{String constants are
constant}\label{string-constants-are-constant}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \NormalTok{array[] = }\StringTok{"Hi!"}\NormalTok{; }\CommentTok{// array contains a mutable copy}
\NormalTok{strcpy(array, }\StringTok{"OK"}\NormalTok{);}

\DataTypeTok{char} \NormalTok{*ptr = }\StringTok{"Can't change me"}\NormalTok{; }\CommentTok{// ptr points to some immutable memory}
\NormalTok{strcpy(ptr, }\StringTok{"Will not work"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\subsection{Buffer overflow/ underflow}\label{buffer-overflow-underflow}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#define N (10)}
\DataTypeTok{int} \NormalTok{i = N, array[N];}
\KeywordTok{for}\NormalTok{( ; i >= }\DecValTok{0}\NormalTok{; i--) array[i] = i;}
\end{Highlighting}
\end{Shaded}

C does not check that pointers are valid. The above example writes into
\texttt{array{[}10{]}} which is outside the array bounds. This can cause
memory corruption because that memory location is probably being used
for something else.\\In practice, this can be harder to spot because the
overflow/underflow may occur in a library call e.g.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gets(array); }\CommentTok{// Let's hope the input is shorter than my array!}
\end{Highlighting}
\end{Shaded}

\subsection{Returning pointers to automatic
variables}\label{returning-pointers-to-automatic-variables}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{*f() \{}
    \DataTypeTok{int} \NormalTok{result = }\DecValTok{42}\NormalTok{;}
    \DataTypeTok{static} \DataTypeTok{int} \NormalTok{imok;}
    \KeywordTok{return} \NormalTok{&imok; }\CommentTok{// OK - static variables are not on the stack}
    \KeywordTok{return} \NormalTok{&result; }\CommentTok{// Not OK}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Automatic variables are bound to stack memory only for the lifetime of
the function.\\After the function returns it is an error to continue to
use the memory.

\subsection{Insufficient memory
allocation}\label{insufficient-memory-allocation}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{User \{}
   \DataTypeTok{char} \NormalTok{name[}\DecValTok{100}\NormalTok{];}
\NormalTok{\};}
\KeywordTok{typedef} \KeywordTok{struct} \NormalTok{User user_t;}

\NormalTok{user_t *user = (user_t *) malloc(}\KeywordTok{sizeof}\NormalTok{(user));}
\end{Highlighting}
\end{Shaded}

In the above example, we needed to allocate enough bytes for the struct.
Instead we allocated enough bytes to hold a pointer. Once we start using
the user pointer we will corrupt memory. Correct code is show bellow.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{User \{}
   \DataTypeTok{char} \NormalTok{name[}\DecValTok{100}\NormalTok{];}
\NormalTok{\};}
\KeywordTok{typedef} \KeywordTok{struct} \NormalTok{User user_t;}

\NormalTok{user_t * user = (user_t *) malloc(}\KeywordTok{sizeof}\NormalTok{(user_t));}
\end{Highlighting}
\end{Shaded}

\subsection{Using uninitialized
variables}\label{using-uninitialized-variables}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{myfunction() \{}
  \DataTypeTok{int} \NormalTok{x;}
  \DataTypeTok{int} \NormalTok{y = x + }\DecValTok{2}\NormalTok{;}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

Automatic variables hold garbage (whatever bit pattern happened to be in
memory). It is an error to assume that it will always be initialized to
zero.

\subsection{Assuming Uninitialized memory will be
zeroed}\label{assuming-uninitialized-memory-will-be-zeroed}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \NormalTok{myfunct() \{}
   \DataTypeTok{char} \NormalTok{array[}\DecValTok{10}\NormalTok{];}
   \DataTypeTok{char} \NormalTok{*p = malloc(}\DecValTok{10}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

Automatic (temporary variables) are not automatically initialized to
zero.\\Heap allocations using malloc are not automatically initialized
to zero.

\subsection{Double-free}\label{double-free}

\begin{Shaded}
\begin{Highlighting}[]
  \DataTypeTok{char} \NormalTok{*p = malloc(}\DecValTok{10}\NormalTok{);}
  \NormalTok{free(p);}
\CommentTok{//  .. later ...}
  \NormalTok{free(p); }
\end{Highlighting}
\end{Shaded}

It is an error to free the same block of memory twice.

\subsection{Dangling pointers}\label{dangling-pointers}

\begin{Shaded}
\begin{Highlighting}[]
  \DataTypeTok{char} \NormalTok{*p = malloc(}\DecValTok{10}\NormalTok{);}
  \NormalTok{strcpy(p, }\StringTok{"Hello"}\NormalTok{);}
  \NormalTok{free(p);}
\CommentTok{//  .. later ...}
  \NormalTok{strcpy(p,}\StringTok{"World"}\NormalTok{); }
\end{Highlighting}
\end{Shaded}

Pointers to freed memory should not be used. A defensive programming
practice is to set pointers to null as soon as the memory is freed.

It is a good idea to turn free into the following snippet that
automatically sets the freed variable to null right after:(vim -
ultisnips)

\begin{verbatim}
snippet free "free(something)" b
free(${1});
$1 = NULL;
${2}
endsnippet
\end{verbatim}

\section{Logic and Program flow
mistakes}\label{logic-and-program-flow-mistakes}

\subsection{Forgetting break}\label{forgetting-break}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{flag = }\DecValTok{1}\NormalTok{; }\CommentTok{// Will print all three lines.}
\KeywordTok{switch}\NormalTok{(flag) \{}
  \KeywordTok{case} \DecValTok{1}\NormalTok{: printf(}\StringTok{"I'm printed}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
  \KeywordTok{case} \DecValTok{2}\NormalTok{: printf(}\StringTok{"Me too}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
  \KeywordTok{case} \DecValTok{3}\NormalTok{: printf(}\StringTok{"Me three}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Case statements without a break will just continue onto the code of the
next case statement. Correct code is show bellow. The break for the last
statements is unnecessary because there are no more cases to be executed
after the last one. However if more are added, it can cause some bugs.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{flag = }\DecValTok{1}\NormalTok{; }\CommentTok{// Will print all three lines.}
\KeywordTok{switch}\NormalTok{(flag) \{}
  \KeywordTok{case} \DecValTok{1}\NormalTok{: }
    \NormalTok{printf(}\StringTok{"I'm printed}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \KeywordTok{break}\NormalTok{;}
  \KeywordTok{case} \DecValTok{2}\NormalTok{: }
    \NormalTok{printf(}\StringTok{"Me too}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \KeywordTok{break}\NormalTok{;}
  \KeywordTok{case} \DecValTok{3}\NormalTok{: }
    \NormalTok{printf(}\StringTok{"Me three}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \KeywordTok{break}\NormalTok{; }\CommentTok{//unnecessary}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Equal vs equality}\label{equal-vs-equality}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{answer = }\DecValTok{3}\NormalTok{; }\CommentTok{// Will print out the answer.}
\KeywordTok{if} \NormalTok{(answer = }\DecValTok{42}\NormalTok{) \{ printf(}\StringTok{"I've solved the answer! It's %d"}\NormalTok{, answer);\}}
\end{Highlighting}
\end{Shaded}

\subsection{Undeclared or incorrectly prototyped
functions}\label{undeclared-or-incorrectly-prototyped-functions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{time_t start = time();}
\end{Highlighting}
\end{Shaded}

The system function `time' actually takes a parameter (the pointer to
some memory that can receive the time\_t structure. The compiler did not
catch this error because the programmer did not provide a valid function
prototype by including \texttt{time.h}

\subsection{Extra Semicolons}\label{extra-semicolons}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < }\DecValTok{5}\NormalTok{; i++) ; printf(}\StringTok{"I'm printed once"}\NormalTok{);}
\KeywordTok{while}\NormalTok{(x < }\DecValTok{10}\NormalTok{); x++ ; }\CommentTok{// X is never incremented}
\end{Highlighting}
\end{Shaded}

However, the following code is perfectly OK.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < }\DecValTok{5}\NormalTok{; i++)\{}
    \NormalTok{printf(}\StringTok{"%d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, i);;;;;;;;;;;;;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It is OK to have this kind of code, because the C language uses
semicolons (;) to separate statements. If there is no statement in
between semicolons, then there is nothing to do and the compiler moves
on to the next statement

\section{Other Gotchas}\label{other-gotchas}

\subsection{C Preprocessor macros and
side-effects}\label{c-preprocessor-macros-and-side-effects}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#define min(a,b) ((a)<(b) ? (a) : (b))}
\DataTypeTok{int} \NormalTok{x = }\DecValTok{4}\NormalTok{;}
\KeywordTok{if}\NormalTok{(min(x++, }\DecValTok{100}\NormalTok{)) printf(}\StringTok{"%d is six"}\NormalTok{, x);}
\end{Highlighting}
\end{Shaded}

Macros are simple text substitution so the above example expands to
\texttt{x++\ \textless{}\ 100\ ?\ x++\ :\ 100} (parenthesis omitted for
clarity)

\subsection{C Preprocessor macros and
precedence}\label{c-preprocessor-macros-and-precedence}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#define min(a,b) a<b ? a : b}
\DataTypeTok{int} \NormalTok{x = }\DecValTok{99}\NormalTok{;}
\DataTypeTok{int} \NormalTok{r = }\DecValTok{10} \NormalTok{+ min(}\DecValTok{99}\NormalTok{, }\DecValTok{100}\NormalTok{); }\CommentTok{// r is 100!}
\end{Highlighting}
\end{Shaded}

Macros are simple text substitution so the above example expands to
\texttt{10\ +\ 99\ \textless{}\ 100\ ?\ 99\ :\ 100}
