\subsection{When I re-run my server code it doesn't work!
Why?}\label{when-i-re-run-my-server-code-it-doesnt-work-why}

By default, after a socket is closed the port enters a time-out state
during which time it cannot be re-used (`bound to a new socket').

This behavior can be disabled by setting the socket option REUSEPORT
before bind-ing to a port:

\begin{Shaded}
\begin{Highlighting}[]
    \DataTypeTok{int} \NormalTok{optval = }\DecValTok{1}\NormalTok{;}
    \NormalTok{setsockopt(sock_fd, SOL_SOCKET, SO_REUSEPORT, &optval, }\KeywordTok{sizeof}\NormalTok{(optval));}

    \NormalTok{bind(sock_fd, ...)}
\end{Highlighting}
\end{Shaded}

\subsection{Can a TCP client bind to a particular
port?}\label{can-a-tcp-client-bind-to-a-particular-port}

Yes! In fact outgoing TCP connections are automatically bound to an
unused port on the client. Usually it's unnecessary to explicitly set
the port on the client because the system will intelligently find an
unusued port on a reasonable interface (e.g.~the wireless card, if
currently connected by WiFi connection). However it can be useful if you
needed to specifically choose a particular ethernet card, or if a
firewall only allows outgoing connections from a particular range of
port values.

To explicitly bind to an ethernet interface and port, call \texttt{bind}
before \texttt{connect}

\subsection{Who connected to my
server?}\label{who-connected-to-my-server}

The \texttt{accept} system call can optionally provide information about
the remote client, by passing in a sockaddr struct. Different protocols
have differently variants of the \texttt{struct\ sockaddr}, which are
different sizes. The simplest struct to use is the
\texttt{sockaddr\_storage} which is sufficiently large to represent all
possible types of sockaddr. Notice that C does not have any model of
inheritance. Therefore we need to explicitly cast our struct to the
`base type' struct sockaddr.

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{struct} \NormalTok{sockaddr_storage clientaddr;}
    \NormalTok{socklen_t clientaddrsize = }\KeywordTok{sizeof}\NormalTok{(clientaddr);}
    \DataTypeTok{int} \NormalTok{client_id = accept(passive_socket, (}\KeywordTok{struct} \NormalTok{sockaddr *) &clientaddr, &clientaddrsize);}
\end{Highlighting}
\end{Shaded}

We've already seen \texttt{getaddrinfo} that can build a linked list of
addrinfo entries (and each one of these can include socket configuration
data). What if we wanted to turn socket data into IP and port addresses?
Enter \texttt{getnameinfo} that can be used to convert a local or remote
socket information into a domain name or numeric IP. Similarly the port
number can be represented as a service name (e.g. ``http'' for port 80).
In the example below we request numeric versions for the client IP
address and client port number.

\begin{Shaded}
\begin{Highlighting}[]
    \NormalTok{socklen_t clientaddrsize = }\KeywordTok{sizeof}\NormalTok{(clientaddr);}
    \DataTypeTok{int} \NormalTok{client_id = accept(sock_id, (}\KeywordTok{struct} \NormalTok{sockaddr *) &clientaddr, &clientaddrsize);}
    \DataTypeTok{char} \NormalTok{host[}\DecValTok{256}\NormalTok{], port[}\DecValTok{256}\NormalTok{];}
    \NormalTok{getnameinfo((}\KeywordTok{struct} \NormalTok{sockaddr *) &clientaddr, clientaddrsize, host, }\KeywordTok{sizeof}\NormalTok{(host), port, }\KeywordTok{sizeof}\NormalTok{(port), NI_NUMERICHOST | NI_NUMERICSERV);}
\end{Highlighting}
\end{Shaded}

Todo: Discuss NI\_MAXHOST and NI\_MAXSERV, and NI\_NUMERICHOST

\subsection{getnameinfo Example: What's my IP
address?}\label{getnameinfo-example-whats-my-ip-address}

To obtain a linked list of IP addresses of the current machine use
\texttt{getifaddrs} which will return a linked list of IPv4 and IPv6 IP
addresses (and potentially other interfaces too). We can examine each
entry and use \texttt{getnameinfo} to print the host's IP address.\\The
ifaddrs struct includes the family but does not include the sizeof the
struct. Therefore we need to manually determine the struct sized based
on the family (IPv4 v IPv6)

\begin{Shaded}
\begin{Highlighting}[]
 \NormalTok{(family == AF_INET) ? }\KeywordTok{sizeof}\NormalTok{(}\KeywordTok{struct} \NormalTok{sockaddr_in) : }\KeywordTok{sizeof}\NormalTok{(}\KeywordTok{struct} \NormalTok{sockaddr_in6)}
\end{Highlighting}
\end{Shaded}

The complete code is shown below.

\begin{Shaded}
\begin{Highlighting}[]
    \DataTypeTok{int} \NormalTok{required_family = AF_INET; }\CommentTok{// Change to AF_INET6 for IPv6}
    \KeywordTok{struct} \NormalTok{ifaddrs *myaddrs, *ifa;}
    \NormalTok{getifaddrs(&myaddrs);}
    \DataTypeTok{char} \NormalTok{host[}\DecValTok{256}\NormalTok{], port[}\DecValTok{256}\NormalTok{];}
    \KeywordTok{for} \NormalTok{(ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next) \{}
        \DataTypeTok{int} \NormalTok{family = ifa->ifa_addr->sa_family;}
        \KeywordTok{if} \NormalTok{(family == required_family && ifa->ifa_addr) \{}
            \KeywordTok{if} \NormalTok{(}\DecValTok{0} \NormalTok{== getnameinfo(ifa->ifa_addr,}
                                \NormalTok{(family == AF_INET) ? }\KeywordTok{sizeof}\NormalTok{(}\KeywordTok{struct} \NormalTok{sockaddr_in) :}
                                \KeywordTok{sizeof}\NormalTok{(}\KeywordTok{struct} \NormalTok{sockaddr_in6),}
                                \NormalTok{host, }\KeywordTok{sizeof}\NormalTok{(host), port, }\KeywordTok{sizeof}\NormalTok{(port), NI_NUMERICHOST | NI_NUMERICSERV  ))}
                \NormalTok{puts(host);}
            \NormalTok{\}}
        \NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{What's my machine's IP address (shell
version)}\label{whats-my-machines-ip-address-shell-version}

Answer: use \texttt{ifconfig} (or Windows's ipconfig)\\However this
command generates a lot of output for each interface, so we can filter
the output using grep

\begin{verbatim}
ifconfig | grep inet

Example output:
    inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 
    inet 127.0.0.1 netmask 0xff000000 
    inet6 ::1 prefixlen 128 
    inet6 fe80::7256:81ff:fe9a:9141%en1 prefixlen 64 scopeid 0x5 
    inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
\end{verbatim}
