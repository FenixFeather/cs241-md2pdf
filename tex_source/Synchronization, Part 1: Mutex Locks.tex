\chapter{Synchronization}tical
Section?}\label{what-is-a-critical-section}

A critical section is a section of code that can only be executed by one
thread at a time, if the program is to function correctly. If two
threads (or processes) were to execute code inside the critical section
at the same time then it is possible that program may no longer have
correct behavior.

\subsection{Is just incrementing a variable a critical
section?}\label{is-just-incrementing-a-variable-a-critical-section}

Possibly. Incrementing a variable (\texttt{i++}) is performed in three
individual steps: Copy the memory contents to the CPU register.
Increment the value in the CPU. Store the new value in memory. If the
memory location is only accessible by one thread (e.g.~automatic
variable \texttt{i} below) then there is no possibility of a race
condition and no Critical Section associated with \texttt{i}. However
the \texttt{sum} variable is a global variable and accessed by two
threads. It is possible that two threads may attempt to increment the
variable at the same time.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <stdio.h>}
\OtherTok{#include <pthread.h>}
\CommentTok{// Compile with -pthread}

\DataTypeTok{int} \NormalTok{sum = }\DecValTok{0}\NormalTok{; }\CommentTok{//shared}

\DataTypeTok{void} \NormalTok{*countgold(}\DataTypeTok{void} \NormalTok{*param) \{}
    \DataTypeTok{int} \NormalTok{i; }\CommentTok{//local to each thread}
    \KeywordTok{for} \NormalTok{(i = }\DecValTok{0}\NormalTok{; i < }\DecValTok{10000000}\NormalTok{; i++) \{}
        \NormalTok{sum += }\DecValTok{1}\NormalTok{;}
    \NormalTok{\}}
    \KeywordTok{return} \NormalTok{NULL;}
\NormalTok{\}}

\DataTypeTok{int} \NormalTok{main() \{}
    \NormalTok{pthread_t tid1, tid2;}
    \NormalTok{pthread_create(&tid1, NULL, countgold, NULL);}
    \NormalTok{pthread_create(&tid2, NULL, countgold, NULL);}
    
    \CommentTok{//Wait for both threads to finish:}
    \NormalTok{pthread_join(tid1, NULL);}
    \NormalTok{pthread_join(tid2, NULL);}
    
    \NormalTok{printf(}\StringTok{"ARRRRG sum is %d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, sum);}
    \KeywordTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Typical output of the above code is \texttt{ARGGGH\ sum\ is\ 8140268}\\A
different sum is printed each time the program is run because there is a
race condition; the code does not stop two threads from reading-writing
\texttt{sum} at the same time. For example both threads copy the current
value of sum into CPU that runs each thread (let's pick 123). Both
threads increment one to their own copy. Both threads write back the
value (124). If the threads had accessed the sum at different times then
the count would have been 125.

\subsection{How do I ensure only one thread at a time can access a
global
variable?}\label{how-do-i-ensure-only-one-thread-at-a-time-can-access-a-global-variable}

You mean, ``Help - I need a mutex!''\\If one thread is currently inside
a critical section we would like another thread to wait until the first
thread is complete. For this purpose we can use a mutex (short for
Mutual Exclusion).

For simple examples the smallest amount of code we need to add is just
three lines:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER; }\CommentTok{// global variable}
\NormalTok{pthread_mutex_lock(&m); }\CommentTok{// start of Critical Section}
\NormalTok{pthread_mutex_unlock(&m); }\CommentTok{//end of Critical Section}
\end{Highlighting}
\end{Shaded}

Once we are finished with the mutex we should also call
\texttt{pthread\_mutex\_destroy(\&m)} too. Note, you can only destroy an
unlocked mutex. Calling destroy on a destroyed lock, initializing an
initialized lock, locking an already locked lock, unlocking an unlocked
lock etc are unsupported (at least for default mutexes) and usually
result in undefined behavior.

\subsection{If I lock a mutex, does it stop all other
threads?}\label{if-i-lock-a-mutex-does-it-stop-all-other-threads}

No, the other threads will continue. It's only when a thread attempts to
lock a mutex that is already locked, will the thread have to wait. As
soon as the original thread unlocks the mutex, the second (waiting)
thread will acquire the lock and be able to continue.

\subsection{Are there other ways to create a
mutex?}\label{are-there-other-ways-to-create-a-mutex}

Yes. You can use the macro PTHREAD\_MUTEX\_INITIALIZER only for global
(`static') variables.\\m = PTHREAD\_MUTEX\_INITIALIZER is equivalent to
the more general purpose\\\texttt{pthread\_mutex\_init(\&m,NULL)}. The
init version includes options to trade performance for additional
error-checking and advanced sharing options.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pthread_mutex_t *lock = malloc(}\KeywordTok{sizeof}\NormalTok{(pthread_mutex_t)); }
\NormalTok{pthread_mutex_init(lock, NULL);}
\CommentTok{//later}
\NormalTok{pthread_mutex_destroy(lock);}
\NormalTok{free(lock);}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{So\ pthread\_mutex\_lock} stops the
other threads when they read the same
variable?}{So pthread\_mutex\_lock stops the other threads when they read the same variable?}}\label{so-pthreadux5fmutexux5flock-stops-the-other-threads-when-they-read-the-same-variable}

No.A mutex is not that smart - it works with code(threads) not data.
Only when another thread calls \texttt{lock} on a locked mutex will the
second thread need to wait until the mutex is unlocked.

\subsection{Can I create mutex before
fork-ing?}\label{can-i-create-mutex-before-fork-ing}

Yes - however the child and parent process will not share virtual memory
and each one will have a mutex independent of the other.

(Advanced note: There are advanced options using shared memory that
allow a child and parent to share a mutex if it's created with the
correct options and uses a shared memory segment. See
{[}{[}stackoverflow
example\textbar{}\url{http://stackoverflow.com/questions/19172541/procs-fork-and-mutexes}{]}{]}
)

\subsection{If one thread locks a mutex can another thread unlock
it?}\label{if-one-thread-locks-a-mutex-can-another-thread-unlock-it}

No. The same thread must unlock it.

\subsection{Can I use two or more mutex
locks?}\label{can-i-use-two-or-more-mutex-locks}

Yes! In fact it's common to have one lock per data structure that you
need to update.

If you only have one lock then they may be significant contention for
the lock between two threads that was unnecessary. For example if two
threads were updating two different counters it might not be necessary
to use the same lock.

However simply creating many locks is insufficient: It's important to be
able to reason about critical sections e.g.~it's important that one
thread can't read two data structures while they are being updated and
temporarily in an inconsistent state.

\subsection{Is there any overhead in calling lock and
unlock?}\label{is-there-any-overhead-in-calling-lock-and-unlock}

There is a small overhead amount of overhead of calling
\texttt{pthread\_mutex\_lock} and \texttt{\_unlock}; however this is the
price you pay for correctly functioning programs!

\subsection{Simplest complete example?}\label{simplest-complete-example}

A complete example is shown below

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <stdio.h>}
\OtherTok{#include <pthread.h>}

\CommentTok{// Compile with -pthread}
\CommentTok{// Create a mutex this ready to be locked!}
\NormalTok{pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;}

\DataTypeTok{int} \NormalTok{sum = }\DecValTok{0}\NormalTok{;}

\DataTypeTok{void} \NormalTok{*countgold(}\DataTypeTok{void} \NormalTok{*param) \{}
    \DataTypeTok{int} \NormalTok{i;}
    
    \CommentTok{//Same thread that locks the mutex must unlock it}
    \CommentTok{//Critical section is just 'sum += 1'}
    \CommentTok{//However locking and unlocking a million times}
    \CommentTok{//has significant overhead in this simple answer}
    
    \NormalTok{pthread_mutex_lock(&m);}

    \CommentTok{// Other threads that call lock will have to wait until we call unlock}

    \KeywordTok{for} \NormalTok{(i = }\DecValTok{0}\NormalTok{; i < }\DecValTok{10000000}\NormalTok{; i++) \{}
    \NormalTok{sum += }\DecValTok{1}\NormalTok{;}
    \NormalTok{\}}
    \NormalTok{pthread_mutex_unlock(&m);}
    \KeywordTok{return} \NormalTok{NULL;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In the code above, the thread gets the lock to the counting house before
entering. The critical section is only the \texttt{sum+=1} so the
following version is also correct but slower -

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{for} \NormalTok{(i = }\DecValTok{0}\NormalTok{; i < }\DecValTok{10000000}\NormalTok{; i++) \{}
        \NormalTok{pthread_mutex_lock(&m);}
        \NormalTok{sum += }\DecValTok{1}\NormalTok{;}
        \NormalTok{pthread_mutex_unlock(&m);}
    \NormalTok{\}}
    \KeywordTok{return} \NormalTok{NULL;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This process runs a slower because we lock and unlock the mutex a
million times, which is expensive - at least compared with incrementing
a variable. (And in this simple example we didn't really need threads -
we could have added up twice!) A faster multi-thread example would be to
add one million using an automatic(local) variable and only then adding
it to a shared total after the calculation loop has finished:

\begin{Shaded}
\begin{Highlighting}[]
    \DataTypeTok{int} \NormalTok{local = }\DecValTok{0}\NormalTok{;}
    \KeywordTok{for} \NormalTok{(i = }\DecValTok{0}\NormalTok{; i < }\DecValTok{10000000}\NormalTok{; i++) \{}
       \NormalTok{local += }\DecValTok{1}\NormalTok{;}
    \NormalTok{\}}

    \NormalTok{pthread_mutex_lock(&m);}
    \NormalTok{sum += local;}
    \NormalTok{pthread_mutex_unlock(&m);}

    \KeywordTok{return} \NormalTok{NULL;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{How do I find out more?}\label{how-do-i-find-out-more}

\href{http://angrave.github.io/sys}{Play!} Read the man page!

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  {[}{[}\url{http://linux.die.net/man/3/pthread_mutex_lock}{]}{]}
\item
  {[}{[}\url{http://linux.die.net/man/3/pthread_mutex_unlock}{]}{]}
\item
  {[}{[}\url{http://linux.die.net/man/3/pthread_mutex_init}{]}{]}
\item
  {[}{[}\url{http://linux.die.net/man/3/pthread_mutex_destroy}{]}{]}
\end{itemize}
