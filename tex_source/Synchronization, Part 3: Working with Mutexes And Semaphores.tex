\subsection{What is an atomic
operation?}\label{what-is-an-atomic-operation}

To paraphrase Wikipedia, ``An operation (or set of operations) is atomic
or uninterruptible if it appears to the rest of the system to occur
instantaneously.''\\Without locks, only simple CPU instructions (``read
this byte from memory'') are atomic (indivisible). On a single CPU
system one could temporarily disable interrupts (so a sequence of
operations cannot be interrupted) but in practice atomicity is achieved
by using synchronization primitives, typically a mutex lock.

Incrementing a variable (\texttt{i++}) is \emph{not} atomic because it
requires three distinct steps: Copying the bit pattern from memory into
the CPU; performing a calculation using the CPU's registers; copying the
bit pattern back to memory. During this increment sequence, another
thread or process can still read the old value and other writes to the
same memory would also be over-written when the increment sequence
completes.

\subsection{How do I use mutex lock to make my data-structure
thread-safe?}\label{how-do-i-use-mutex-lock-to-make-my-data-structure-thread-safe}

Note, this is just an introduction - writing high-performance
thread-safe data-structures requires it's own book! Here's a simple data
structure (a stack) that is not thread-safe:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// A simple fixed-sized stack (version 1)}
\DataTypeTok{int} \NormalTok{count;}
\DataTypeTok{double} \NormalTok{values[count];}

\DataTypeTok{void} \NormalTok{push(}\DataTypeTok{double} \NormalTok{v) \{ values[count++] = v; \}}
\DataTypeTok{double} \NormalTok{pop() \{ }\KeywordTok{return} \NormalTok{values[--count]; \}}
\DataTypeTok{int} \NormalTok{is_empty() \{ }\KeywordTok{return} \NormalTok{count == }\DecValTok{0}\NormalTok{; \}}
\end{Highlighting}
\end{Shaded}

Version 1 of the stack is not thread-safe because if two threads call
push or pop at the same time then the results or the stack can be
inconsistent. For example, imagine if two threads call pop at the same
time then both threads may read the same value, both may read the
original count value.

To turn this into a thread-safe data structure we need to identify the
\emph{critical sections} of our code i.e.~which section(s) of the code
must only have one thread at a time. In the above example the
\texttt{push},\texttt{pop} and \texttt{is\_empty} functions access the
same variables (i.e.~memory) and all critical sections for the stack.

While \texttt{push} (and \texttt{pop}) is executing, the datastructure
is an inconsistent state (for example the count may not have been
written to, so may still contain the original value). By wrapping these
methods with a mutex we can ensure that only one thread at a time can
update (or read) the stack.

A candidate `solution' is shown below. Is it correct? If not, how will
it fail?

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// An attempt at a thread-safe stack (version 2)}
\DataTypeTok{int} \NormalTok{count;}
\DataTypeTok{double} \NormalTok{values[count];}
\NormalTok{pthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER;}
\NormalTok{pthread_mutex_t m2 = PTHREAD_MUTEX_INITIALIZER;}

\DataTypeTok{void} \NormalTok{push() \{ pthread_mutex_lock(&m1); values[count++] = values; pthread_mutex_unlock(&m1); \}}
\DataTypeTok{double} \NormalTok{pop() \{ pthread_mutex_lock(&m2); }\DataTypeTok{double} \NormalTok{v=values[--count]; pthread_mutex_unlock(&m2); }\KeywordTok{return} \NormalTok{v;\}}
\DataTypeTok{int} \NormalTok{is_empty() \{ pthread_mutex_lock(&m1); }\KeywordTok{return} \NormalTok{count == }\DecValTok{0}\NormalTok{; pthread_mutex_unlock(&m1); \}}
\end{Highlighting}
\end{Shaded}

The above code (`version 2') contains at least one error. Take a moment
to see if you can the error(s) and work out the consequence(s).

If three called \texttt{push()} at the same time the lock \texttt{m1}
ensures that only one thread at time manipulates the stack (two threads
will need to wait until the first thread completes (calls unlock), then
a second thread will be allowed to continue into the critical section
and finally the third thread will be allowed to continue once the second
thread has finished).

A similar argument applies to concurrent calls (calls at the same time)
to \texttt{pop}. However version 2 does not prevent push and pop from
running at the same time because \texttt{push} and \texttt{pop} use two
different mutex locks.

The fix is simple in this case - use the same mutex lock for both the
push and pop functions.

The code has a second error; \texttt{is\_empty} returns after the
comparison and will not unlock the mutex. However the error would not be
spotted immediately. For example, suppose one thread calls
\texttt{is\_empty} and a second thread later calls \texttt{push}. This
thread would mysteriously stop. Using debugger you can discover that the
thread is stuck at the lock() method inside the \texttt{push} method
because the lock was never unlocked by the earlier \texttt{is\_empty}
call. Thus an oversight in one thread led to problems much later in time
in an arbitrary other thread.

A better version is shown below -

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// An attempt at a thread-safe stack (version 3)}
\DataTypeTok{int} \NormalTok{count;}
\DataTypeTok{double} \NormalTok{values[count];}
\NormalTok{pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;}

\DataTypeTok{void} \NormalTok{push(}\DataTypeTok{double} \NormalTok{v) \{ }
  \NormalTok{pthread_mutex_lock(&m); }
  \NormalTok{values[count++] = v;}
  \NormalTok{pthread_mutex_unlock(&m);}
\NormalTok{\}}
\DataTypeTok{double} \NormalTok{pop() \{}
  \NormalTok{pthread_mutex_lock(&m);}
  \DataTypeTok{double} \NormalTok{v = values[--count];}
  \NormalTok{pthread_mutex_unlock(&m);}
  \KeywordTok{return} \NormalTok{v;}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{is_empty() \{}
  \NormalTok{pthread_mutex_lock(&m);}
  \DataTypeTok{int} \NormalTok{result= count == }\DecValTok{0}\NormalTok{;}
  \NormalTok{pthread_mutex_unlock(&m);}
  \KeywordTok{return} \NormalTok{result;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Version 3 is thread-safe (we have ensured mutual exclusion for all of
the critical sections) however there are two points of note:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{is\_empty} is thread-safe but its result may already be out-of
  date i.e.~the stack may no longer be empty by the time the thread gets
  the result!
\item
  There is no protection against underflow (popping on an empty stack)
  or overflow (pushing onto an already-full stack)
\end{itemize}

The latter point can be fixed using counting semaphores.

The implementation assumes a single stack. A more general purpose
version might include the mutex as part of the memory struct and use
pthread\_mutex\_init to initialize the mutex. For example,

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Support for multiple stacks (each one has a mutex)}
\KeywordTok{typedef} \KeywordTok{struct} \NormalTok{stack \{}
  \DataTypeTok{int} \NormalTok{count;}
  \NormalTok{pthread_mutex_t m; }
  \DataTypeTok{double} \NormalTok{*values;}
\NormalTok{\} stack_t;}

\NormalTok{stack_t* stack_create(}\DataTypeTok{int} \NormalTok{capacity) \{}
  \NormalTok{stack_t *result = malloc(}\KeywordTok{sizeof}\NormalTok{(stack_t));}
  \NormalTok{result->count = }\DecValTok{0}\NormalTok{;}
  \NormalTok{result->values = malloc(}\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{double}\NormalTok{) * capacity);}
  \NormalTok{pthread_mutex_init(&result->m, NULL);}
  \KeywordTok{return} \NormalTok{result;}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{stack_destroy(stack_t *s) \{}
  \NormalTok{free(s->values);}
  \NormalTok{pthread_mutex_destroy(&s->m);}
  \NormalTok{free(s);}
\NormalTok{\}}
\CommentTok{// Warning no underflow or overflow checks!}

\DataTypeTok{void} \NormalTok{push(stack_t *s, }\DataTypeTok{double} \NormalTok{v) \{ }
  \NormalTok{pthread_mutex_lock(&s->m); }
  \NormalTok{s->values[(s->count)++] = v; }
  \NormalTok{pthread_mutex_unlock(&s->m); \}}

\DataTypeTok{double} \NormalTok{pop(stack_t *s) \{ }
  \NormalTok{pthread_mutex_lock(&s->m); }
  \DataTypeTok{double} \NormalTok{v = s->values[--(s->count)]; }
  \NormalTok{pthread_mutex_unlock(&s->m); }
  \KeywordTok{return} \NormalTok{v;}
\NormalTok{\}}

\DataTypeTok{int} \NormalTok{is_empty(stack_t *s) \{ }
  \NormalTok{pthread_mutex_lock(&s->m); }
  \DataTypeTok{int} \NormalTok{result = s->count == }\DecValTok{0}\NormalTok{; }
  \NormalTok{pthread_mutex_unlock(&s->m);}
  \KeywordTok{return} \NormalTok{result;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Example use:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{main() \{}
    \NormalTok{stack_t *s1 = stack_create(}\DecValTok{10} \CommentTok{/* Max capacity*/}\NormalTok{);}
    \NormalTok{stack_t *s2 = stack_create(}\DecValTok{10}\NormalTok{);}
    \NormalTok{push(s1, }\FloatTok{3.141}\NormalTok{);}
    \NormalTok{push(s2, pop(s1));}
    \NormalTok{stack_destroy(s2);}
    \NormalTok{stack_destroy(s1);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{When can I destroy the
mutex?}\label{when-can-i-destroy-the-mutex}

You can only destroy an unlocked mutex

\subsection{Can I copy a pthread\_mutex\_t to a new memory
locaton?}\label{can-i-copy-a-pthreadux5fmutexux5ft-to-a-new-memory-locaton}

No, copying the bytes of the mutex to a new memory location and then
using the copy is \emph{not} supported.

\subsection{What would a simple implementation of a mutex look
like?}\label{what-would-a-simple-implementation-of-a-mutex-look-like}

A simple (but incorrect!) suggestion is shown below. The \texttt{unlock}
function simply unlocks the mutex and returns. The lock function first
checks to see if the lock is already locked. If it is currently locked,
it will keep checking again until another thread has unlocked the mutex.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Version 1 (Incorrect!)}

\DataTypeTok{void} \NormalTok{lock(mutex_t *m) \{}
  \KeywordTok{while}\NormalTok{(m->locked) \{ }\CommentTok{/*Locked? Nevermind - just loop and check again!*/} \NormalTok{\}}

  \NormalTok{m->locked = }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{void} \NormalTok{unlock(mutex_t *m) \{}
  \NormalTok{m->locked = }\DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Version 1 uses `busy-waiting' (unnecessarily wasting CPU resources)
however there is a more serious problem: We have a race-condition!

If two threads both called \texttt{lock} concurrently it is possible
that both threads would read `m\_locked' as zero. Thus both threads
would believe they have exclusive access to the lock and both threads
will continue. Ooops!

We might attempt to reduce the CPU overhead a little by calling
\texttt{pthread\_yield()} inside the loop - pthread\_yield suggests to
the operating system that the thread does not the CPU for a short while,
so the CPU may be assigned to threads that are waiting to run. But does
not fix the race-condition. We need a better implementation - can you
work how to prevent the race-condition?

\subsection{How can I force my threads to wait if the stack is empty or
full?}\label{how-can-i-force-my-threads-to-wait-if-the-stack-is-empty-or-full}

Use counting semaphores! Use a counting semaphore to keep track of how
many spaces remain and another semaphore to keep to track the number of
items in the stack. We will call these two semaphores `sremain' and
`sitems'. Remember \texttt{sem\_wait} will wait if the semaphore's count
has been decremented to zero (by another thread calling sem\_post).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Sketch #1}

\NormalTok{sem_t sitems;}
\NormalTok{sem_t sremain;}
\DataTypeTok{void} \NormalTok{stack_init()\{}
  \NormalTok{sem_init(&sitems, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{);}
  \NormalTok{sem_init(&sremain, }\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{);}
\NormalTok{\}}


\DataTypeTok{double} \NormalTok{pop() \{}
  \CommentTok{// Wait until there's at least one item}
  \NormalTok{sem_wait(&sitems);}
  \NormalTok{...}

\DataTypeTok{double} \NormalTok{push(}\DataTypeTok{double} \NormalTok{v) \{}
  \CommentTok{// Wait until there's at least one space}
  \NormalTok{sem_wait(&sremain);}
  \NormalTok{...}
\end{Highlighting}
\end{Shaded}

Sketch \#2 has implemented the \texttt{post} too early. Another thread
waiting in push can erroneously attempt to write into a full stack (and
similarly a thread waiting in the pop() is allowed to continue too
early).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Sketch #2 (Error!)}
\DataTypeTok{double} \NormalTok{pop() \{}
  \CommentTok{// Wait until there's at least one item}
  \NormalTok{sem_wait(&sitems);}
  \NormalTok{sem_post(&sremain); }\CommentTok{// error! wakes up pushing() thread too early}
  \KeywordTok{return} \NormalTok{values[--count];}
\NormalTok{\}}
\DataTypeTok{double} \NormalTok{push(}\DataTypeTok{double} \NormalTok{v) \{}
  \CommentTok{// Wait until there's at least one space}
  \NormalTok{sem_wait(&sremain);}
  \NormalTok{sem_post(&sitems); }\CommentTok{// error! wakes up a popping() thread too early}
  \NormalTok{values[count++] = v;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Sketch 3 implements the correct semaphore logic but can you spot the
error?

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Sketch #3 (Error!)}
\DataTypeTok{double} \NormalTok{pop() \{}
  \CommentTok{// Wait until there's at least one item}
  \NormalTok{sem_wait(&sitems);}
  \DataTypeTok{double} \NormalTok{v= values[--count];}
  \NormalTok{sem_post(&sremain);}
  \KeywordTok{return} \NormalTok{v;}
\NormalTok{\}}

\DataTypeTok{double} \NormalTok{push(}\DataTypeTok{double} \NormalTok{v) \{}
  \CommentTok{// Wait until there's at least one space}
  \NormalTok{sem_wait(&sremain);}
  \NormalTok{values[count++] = v;}
  \NormalTok{sem_post(&sitems); }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Sketch 3 correctly enforces buffer full and buffer empty conditions
using semaphores. However there is no \emph{mutual exclusion}: Two
threads can be in the \emph{critical section} at the same time, which
would corrupt the data structure (or least lead to data loss). The fix
is to wrap a mutex around the critical section:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Simple single stack - see above example on how to convert this into a multiple stacks.}
\CommentTok{// Also a robust POSIX implementation would check for EINTR and error codes of sem_wait.}

\CommentTok{// PTHREAD_MUTEX_INITIALIZER for statics (use pthread_mutex_init() for stack/heap memory)}

\NormalTok{pthread_mutex_t m= PTHREAD_MUTEX_INITIALIZER; }
\DataTypeTok{int} \NormalTok{count = }\DecValTok{0}\NormalTok{;}
\DataTypeTok{double} \NormalTok{values[}\DecValTok{10}\NormalTok{];}
\NormalTok{sem_t sitems, sremain;}

\DataTypeTok{void} \NormalTok{init() \{}
  \NormalTok{sem_init(&sitems, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{);}
  \NormalTok{sem_init(&sremains, }\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{); }\CommentTok{// 10 spaces}
\NormalTok{\}}

\DataTypeTok{double} \NormalTok{pop() \{}
  \CommentTok{// Wait until there's at least one item}
  \NormalTok{sem_wait(&sitems);}

  \NormalTok{pthread_mutex_lock(&m); }\CommentTok{// CRITICAL SECTION}
  \DataTypeTok{double} \NormalTok{v= values[--count];}
  \NormalTok{pthread_mutex_unlock(&m);}

  \NormalTok{sem_post(&sremain); }\CommentTok{// Hey world, there's at least one space}
  \KeywordTok{return} \NormalTok{v;}
\NormalTok{\}}

\DataTypeTok{double} \NormalTok{push(}\DataTypeTok{double} \NormalTok{v) \{}
  \CommentTok{// Wait until there's at least one space}
  \NormalTok{sem_wait(&sremain);}

  \NormalTok{pthread_mutex_lock(&m); }\CommentTok{// CRITICAL SECTION}
  \NormalTok{values[count++] = v;}
  \NormalTok{pthread_mutex_unlock(&m);}

  \NormalTok{sem_post(&sitems); }\CommentTok{// Hey world, there's at least one item}
\NormalTok{\}}
\CommentTok{// Note a robust solution will need to check sem_wait's result for EINTR (more about this later)}
\end{Highlighting}
\end{Shaded}

\subsection{What are the common Mutex
Gotchas?}\label{what-are-the-common-mutex-gotchas}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Locking/unlocking the wrong mutex (due to a silly typo)
\item
  Not unlocking a mutex (due to say an early return during an error
  condition)
\item
  Resource leak (not calling \texttt{pthread\_mutex\_destroy})
\item
  Using an unitialized mutex (or using a mutex that has already been
  destroyed)
\item
  Locking a mutex twice on a thread (without unlocking first)
\item
  Deadlock and Priority Inversion (we will talk about these later)
\end{itemize}
