\subsection{\texorpdfstring{What is \texttt{htons} and when is it
used?}{What is htons and when is it used?}}\label{what-is-htons-and-when-is-it-used}

Integers can be represented in least significant byte first or
most-significant byte first. Either approach is reasonable as long as
the machine itself is internally consistent. For network communications
we need to standardize on agreed format.

\texttt{htons(xyz)} returns the 16 bit unsigned integer `short' value
xyz in network byte order.\\\texttt{htonl(xyz)} returns the 32 bit
unsigned integer `long' value xyz in network byte order.

These functions are read as `host to network'; the inverse functions
(ntohs, ntohl) convert network ordered byte values to host-ordered
ordering. So, is host-ordering little-endian or big-endian? The answer
is - it depends on your machine! It depends on the actual architecture
of the host running the code. If the architecture happens to be the same
as network ordering then the result of these functions is just the
argument. For x86 machines, the host and network ordering \emph{is}
different.

Summary: Whenever you read or write the low level C network structures
(e.g.~port and address information), remember to use the above functions
to ensure correct conversion to/from a machine format. Otherwise the
displayed or specified value may be incorrect.

\subsection{\texorpdfstring{What are the `big 4' network calls used to
create a
server?}{What are the big 4 network calls used to create a server?}}\label{what-are-the-big-4-network-calls-used-to-create-a-server}

The four system calls required to create a TCP server are:
\texttt{socket}, \texttt{bind} \texttt{listen} and \texttt{accept}. Each
has a specific purpose and should be called in the above order

The port information (used by bind) can be set manually (many older
IPv4-only C code examples do this), or be created using
\texttt{getaddrinfo}

We also see examples of setsockopt later too.

\subsection{\texorpdfstring{What is the purpose of calling
\texttt{socket}?}{What is the purpose of calling socket?}}\label{what-is-the-purpose-of-calling-socket}

To create a endpoint for networking communication. A new socket by
itself is not particularly useful; though we've specified either a
packet or stream-based connections it is not bound to a particular
network interface or port. Instead socket returns a network descriptor
that can be used with later calls to bind,listen and accept.

\subsection{\texorpdfstring{What is the purpose of calling
\texttt{bind}}{What is the purpose of calling bind}}\label{what-is-the-purpose-of-calling-bind}

The \texttt{bind} call associates an abstract socket with an actual
network interface and port. It is possible to call bind on a TCP client
however it's unusually unnecessary to specify the outgoing port.

\subsection{\texorpdfstring{What is the purpose of calling
\texttt{listen}}{What is the purpose of calling listen}}\label{what-is-the-purpose-of-calling-listen}

The \texttt{listen} call specifies the queue size for the number of
incoming, unhandled connections i.e.~that have not yet been assigned a
network descriptor by \texttt{accept}\\Typical values for a high
performance server are 128 or more.

\subsection{Why are server sockets
passive?}\label{why-are-server-sockets-passive}

Server sockets do not actively try to connect to another host; instead
they wait for incoming connections. Additionally, server sockets are not
closed when the peer disconnects. Instead when a remote client connects,
it is immediately bumped to an unused port number for future
communications.

\subsection{\texorpdfstring{What is the purpose of calling
\texttt{accept}}{What is the purpose of calling accept}}\label{what-is-the-purpose-of-calling-accept}

Once the server socket has been initialized the server calls
\texttt{accept} to wait for new connections. Unlike \texttt{socket}
\texttt{bind} and \texttt{listen}, this call will block. i.e.~if there
are no new connections, this call will block and only return when a new
client connects.

Note the \texttt{accept} call returns a new file descriptor. This file
descriptor is specific to a particular client. It is common programming
mistake to use the original server socket descriptor for server I/O and
then wonder why networking code has failed.

\subsection{What are the gotchas of creating a
TCP-server?}\label{what-are-the-gotchas-of-creating-a-tcp-server}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Using the socket descriptor of the passive server socket (described
  above)
\item
  Not specifying SOCK\_STREAM requirement for getaddrinfo
\item
  Not being able to re-use an existing port.
\item
  Not initializing the unused struct entries
\item
  The \texttt{bind} call will fail if the port is currently in use
\end{itemize}

Note, ports are per machine- not per process or per user. In other
words, you cannot use port 1234 while another process is using that
port. Worse, ports are by default `tied up' after a process has
finished.

\subsection{Server code example}\label{server-code-example}

A working simple server example is shown below. Note this example is
incomplete - for example it does not close either socket descriptor, or
free up memory created by \texttt{getaddrinfo}

\begin{Shaded}
\begin{Highlighting}[]

\OtherTok{#include <string.h>}
\OtherTok{#include <stdio.h>}
\OtherTok{#include <stdlib.h>}
\OtherTok{#include <sys/types.h>}
\OtherTok{#include <sys/socket.h>}
\OtherTok{#include <netdb.h>}
\OtherTok{#include <unistd.h>}
\OtherTok{#include <arpa/inet.h>}

\DataTypeTok{int} \NormalTok{main(}\DataTypeTok{int} \NormalTok{argc, }\DataTypeTok{char} \NormalTok{**argv)}
\NormalTok{\{}
    \DataTypeTok{int} \NormalTok{s;}
    \DataTypeTok{int} \NormalTok{sock_fd = socket(AF_INET, SOCK_STREAM, }\DecValTok{0}\NormalTok{);}

    \KeywordTok{struct} \NormalTok{addrinfo hints, *result;}
    \NormalTok{memset(&hints, }\DecValTok{0}\NormalTok{, }\KeywordTok{sizeof}\NormalTok{(}\KeywordTok{struct} \NormalTok{addrinfo));}
    \NormalTok{hints.ai_family = AF_INET;}
    \NormalTok{hints.ai_socktype = SOCK_STREAM;}
    \NormalTok{hints.ai_flags = AI_PASSIVE;}

    \NormalTok{s = getaddrinfo(NULL, }\StringTok{"1234"}\NormalTok{, &hints, &result);}
    \KeywordTok{if} \NormalTok{(s != }\DecValTok{0}\NormalTok{) \{}
            \NormalTok{fprintf(stderr, }\StringTok{"getaddrinfo: %s}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, gai_strerror(s));}
            \NormalTok{exit(}\DecValTok{1}\NormalTok{);}
    \NormalTok{\}}

    \KeywordTok{if} \NormalTok{(bind(sock_fd, result->ai_addr, result->ai_addrlen) != }\DecValTok{0}\NormalTok{) \{}
        \NormalTok{perror(}\StringTok{"bind()"}\NormalTok{);}
        \NormalTok{exit(}\DecValTok{1}\NormalTok{);}
    \NormalTok{\}}

    \KeywordTok{if} \NormalTok{(listen(sock_fd, }\DecValTok{10}\NormalTok{) != }\DecValTok{0}\NormalTok{) \{}
        \NormalTok{perror(}\StringTok{"listen()"}\NormalTok{);}
        \NormalTok{exit(}\DecValTok{1}\NormalTok{);}
    \NormalTok{\}}
    
    \KeywordTok{struct} \NormalTok{sockaddr_in *result_addr = (}\KeywordTok{struct} \NormalTok{sockaddr_in *) result->ai_addr;}
    \NormalTok{printf(}\StringTok{"Listening on file descriptor %d, port %d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, sock_fd, ntohs(result_addr->sin_port));}

    \NormalTok{printf(}\StringTok{"Waiting for connection...}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \DataTypeTok{int} \NormalTok{client_fd = accept(sock_fd, NULL, NULL);}
    \NormalTok{printf(}\StringTok{"Connection made: client_fd=%d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, client_fd);}

    \DataTypeTok{char} \NormalTok{buffer[}\DecValTok{1000}\NormalTok{];}
    \DataTypeTok{int} \NormalTok{len = read(client_fd, buffer, }\KeywordTok{sizeof}\NormalTok{(buffer) - }\DecValTok{1}\NormalTok{);}
    \NormalTok{buffer[len] = '\textbackslash{}}\DecValTok{0}\NormalTok{';}

    \NormalTok{printf(}\StringTok{"Read %d chars}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, len);}
    \NormalTok{printf(}\StringTok{"===}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \NormalTok{printf(}\StringTok{"%s}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, buffer);}

    \KeywordTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Why can't my server re-use the
port?}\label{why-cant-my-server-re-use-the-port}

By default a port is not immediately released when the socket is closed
instead the port enters a ``TIMED-WAIT'' state. This can lead to
significant confusion during development because the timeout can make
valid networking code appear to fail.

To be able to immediately re-use a port, specify \texttt{SO\_REUSEPORT}
before binding to the port.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{optval = }\DecValTok{1}\NormalTok{;}
\NormalTok{setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT, &optval, }\KeywordTok{sizeof}\NormalTok{(optval));}

\NormalTok{bind(....}
\end{Highlighting}
\end{Shaded}

An extended stackoverflow introductory discussion of
\texttt{SO\_REUSEPORT} is {[}{[}
here\textbar{}\url{http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t}
{]}{]}.
