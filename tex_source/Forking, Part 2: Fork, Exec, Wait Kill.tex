\subsection{\texorpdfstring{What does the following `exec' example
do?}{What does the following exec example do?}}\label{what-does-the-following-exec-example-do}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{main() \{}
   \NormalTok{close(}\DecValTok{1}\NormalTok{); }\CommentTok{// close standard out}
   \NormalTok{open(}\StringTok{"log.txt"}\NormalTok{, O_RDWR | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR);}
   \NormalTok{puts(}\StringTok{"Captain's log"}\NormalTok{);}
   \NormalTok{chdir(}\StringTok{"/usr/include"}\NormalTok{);}
   \CommentTok{// execl( executable,  arguments for executable including program name and NULL at the end)}

   \NormalTok{execl(}\StringTok{"/bin/ls"}\NormalTok{, }\CommentTok{/* Remaining items sent to ls*/} \StringTok{"/bin/ls"}\NormalTok{, }\StringTok{"."}\NormalTok{, (}\DataTypeTok{char} \NormalTok{*) NULL); }\CommentTok{// "ls ."}
   \NormalTok{perror(}\StringTok{"exec failed"}\NormalTok{);}
   \KeywordTok{return} \DecValTok{0}\NormalTok{; }\CommentTok{// Not expected}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There's no error checking in the above code (we assume close,open,chdir
etc works as expected).

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  open: will use the lowest available file descriptor (i.e.~1) ; so
  standard out now goes to the log file.
\item
  chdir : Change the current directory to /usr/include
\item
  execl : Replace the program image with /bin/ls and call its main()
  method
\item
  perror : We don't expect to get here - if we did then exec failed.
\end{itemize}

\subsection{What does the child inherit from the
parent?}\label{what-does-the-child-inherit-from-the-parent}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Open filehandles. If the parent later seeks, say, to the back to the
  beginning of the file then this will affect the child too (and vice
  versa).
\item
  Signal handlers
\item
  Current working directory\\See the fork man page for more details.
\end{itemize}

\subsection{What is different in the child process than the parent
process?}\label{what-is-different-in-the-child-process-than-the-parent-process}

The process id is different. In the child calling \texttt{getppid()}
(notice the two 'p's) will give the same result as calling getpid() in
the parent. See the fork man page for more details.

\subsection{How do I wait for my child to
finish?}\label{how-do-i-wait-for-my-child-to-finish}

Use \texttt{waitpid} or \texttt{wait}. The parent process will pause
until \texttt{wait} (or \texttt{waitpid}) returns. Note this explanation
glosses over the restarting discussion.

\subsection{What is the fork-exec-wait
pattern}\label{what-is-the-fork-exec-wait-pattern}

A common programming pattern is to call \texttt{fork} followed by
\texttt{exec} and \texttt{wait}. The original process calls fork, which
creates a child process. The child process then uses exec to start
execution of a new program. Meanwhile the parent uses \texttt{wait} (or
\texttt{waitpid}) to wait for the child process to finish.\\See below
for a complete code example.

\subsection{Can I find out the exit value of my
child?}\label{can-i-find-out-the-exit-value-of-my-child}

You can find the lowest 8 bits of the child's exit value (the return
value of \texttt{main()} or value included in \texttt{exit()}): Use the
macros (see \texttt{wait}/\texttt{waitpid} man page) and the
\texttt{wait} or \texttt{waitpid} call

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{status;}
\NormalTok{pid_t child = fork();}
\KeywordTok{if} \NormalTok{(child == -}\DecValTok{1}\NormalTok{) }\KeywordTok{return} \DecValTok{1}\NormalTok{; }\CommentTok{//Failed}
\KeywordTok{if} \NormalTok{(child > }\DecValTok{0}\NormalTok{) \{ }\CommentTok{/* I am the parent - wait for the child to finish */}
  \NormalTok{pid_t pid = waitpid(child, &status, }\DecValTok{0}\NormalTok{);}
  \KeywordTok{if} \NormalTok{(pid != -}\DecValTok{1} \NormalTok{&& WIFEXITED(status)) \{}
     \DataTypeTok{int} \NormalTok{low8bits = WEXITSTATUS(status);}
     \NormalTok{printf(}\StringTok{"Process %d returned %d"} \NormalTok{, pid, low8bits);}
  \NormalTok{\}}
\NormalTok{\} }\KeywordTok{else} \NormalTok{\{ }\CommentTok{/* I am the child */}
 \CommentTok{// do something interesting}
  \NormalTok{execl(}\StringTok{"/bin/ls"}\NormalTok{, }\StringTok{"/bin/ls"}\NormalTok{, }\StringTok{"."}\NormalTok{, (}\DataTypeTok{char} \NormalTok{*) NULL); }\CommentTok{// "ls ."}
\NormalTok{\}}

\end{Highlighting}
\end{Shaded}

\subsection{How do I start a background process that runs as the same
time?}\label{how-do-i-start-a-background-process-that-runs-as-the-same-time}

Don't wait for them! Your parent process can continue to execute code
without having to wait for the child process. Note in practice
background processes can also be disconnected from the parent's input
and output streams by calling \texttt{close} on the open file
descriptors before calling exec.

However child processes that finish before their parent finishes can
become zombies. See the zombie page for more information.

\subsection{Good parents don't let their children become
zombies!}\label{good-parents-dont-let-their-children-become-zombies}

When a child finishes (or terminates) it still takes up a slot in the
kernel process table.\\Only when the child has been `waited on' will the
slot be available again.

A long running program could create many zombies by continually creating
processes and never \texttt{wait}-ing for them.

\subsection{What would be effect of too many
zombies?}\label{what-would-be-effect-of-too-many-zombies}

Eventually there would be insufficient space in the kernel process table
to create a new processes. Thus \texttt{fork()} would fail and could
make the system difficult / impossible to use - for example just logging
in requires a new process!

\subsection{What does the system do to help prevent
zombies?}\label{what-does-the-system-do-to-help-prevent-zombies}

Once a process completes, any of its children will be assigned to
``init'' - the first process with pid of 1. Thus these children would
see getppid() return a value of 1. The init process automatically waits
for all of its children, thus removing zombies from the system.

\subsection{How do I prevent zombies? (Warning: Simplified
answer)}\label{how-do-i-prevent-zombies-warning-simplified-answer}

Wait on your child!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{waitpid(child, &status, }\DecValTok{0}\NormalTok{); }\CommentTok{// Clean up and wait for my child process to finish.}
\end{Highlighting}
\end{Shaded}

Note we assume that the only reason to get a SIGCHLD event is that a
child has finished (this is not quite true - see man page for more
details).

A robust implementation would also check for interrupted status and
include the above in a loop.\\Read on for a discussion of a more robust
implementation.

\subsection{How can I asynchronously wait for my child using
SIGCHLD?}\label{how-can-i-asynchronously-wait-for-my-child-using-sigchld}

The parent gets the signal SIGCHLD when a child completes, so the signal
handler can wait on the process. A slightly simplified version is shown
below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pid_t child;}

\DataTypeTok{void} \NormalTok{cleanup(}\DataTypeTok{int} \NormalTok{signal) \{}
  \DataTypeTok{int} \NormalTok{status;}
  \NormalTok{waitpid(child, &status, }\DecValTok{0}\NormalTok{);}
  \NormalTok{write(}\DecValTok{1}\NormalTok{,}\StringTok{"cleanup!}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,}\DecValTok{9}\NormalTok{);}
\NormalTok{\}}
\DataTypeTok{int} \NormalTok{main() \{}
   \CommentTok{// Register signal handler BEFORE the child can finish}
   \NormalTok{signal(SIGCHLD, cleanup); }\CommentTok{// or better - sigaction}
   \NormalTok{child = fork();}
   \KeywordTok{if} \NormalTok{(child == -}\DecValTok{1}\NormalTok{) \{ exit(EXIT_FAILURE);\}}

   \KeywordTok{if} \NormalTok{(child == }\DecValTok{0}\NormalTok{) \{ }\CommentTok{/* I am the child!*/}
     \CommentTok{// Do background stuff e.g. call exec   }
   \NormalTok{\} }\KeywordTok{else} \NormalTok{\{ }\CommentTok{/* I'm the parent! */}
      \NormalTok{sleep(}\DecValTok{4}\NormalTok{); }\CommentTok{// so we can see the cleanup}
      \NormalTok{puts(}\StringTok{"Parent is done"}\NormalTok{);}
   \NormalTok{\}}
   \KeywordTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\} }
\end{Highlighting}
\end{Shaded}

The above example however misses a couple of subtle points:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  More than one child may have finished but the parent will only get one
  SIGCHLD signal (signals are not queued)
\item
  SIGCHLD signals can be sent for other reasons (e.g.~a child process is
  temporarily stopped)
\end{itemize}

A more robust code to reap zombies is shown below.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \NormalTok{cleanup(}\DataTypeTok{int} \NormalTok{signal) \{}
  \DataTypeTok{int} \NormalTok{status;}
  \KeywordTok{while} \NormalTok{(waitpid((pid_t) (-}\DecValTok{1}\NormalTok{), }\DecValTok{0}\NormalTok{, WNOHANG) > }\DecValTok{0}\NormalTok{) \{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{How do I kill/stop my
child?}\label{how-do-i-killstop-my-child}

Send a signal to the child using \texttt{kill}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kill(child, SIGUSR1); }\CommentTok{// Send a user-defined signal}
\NormalTok{kill(child, SIGTERM); }\CommentTok{// Terminate the child process (the child cannot prevent this)}
\NormalTok{kill(child, SIGINT); }\CommentTok{// Equivalent to CTRL-C (by default closes the process)}
\end{Highlighting}
\end{Shaded}

There is also a kill command available in the shell\\e.g.~get a list of
running processes and then terminate process 45 and process 46

\begin{verbatim}
ps
kill -l 
kill -9 45
kill -s TERM 46
\end{verbatim}
