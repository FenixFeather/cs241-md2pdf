\subsection{The introduction}\label{the-introduction}

The reader-writer problem appears in many different contexts. For
example a web server cache needs to quickly serve the same static page
for many thousands of requests. Occasionally however an author may
decide to update the page.

We will examine one specific form of the reader-writer problem where
there are many readers and some occasional writers and we need to ensure
that a writer gets exclusive access. For performance however readers
should be able to perform the read without waiting for another reader.

See {[}{[}Synchronization,-Part-7:-The-Reader-Writer-Problem{]}{]} for
part 1

\subsection{Candidate solution \#3}\label{candidate-solution-3}

Candidate solutions 1 and 2 are discussed in {[}{[}part
1\textbar{}Synchronization,-Part-7:-The-Reader-Writer-Problem{]}{]}.

In the code below for clarity \texttt{lock} and \texttt{cond\_wait} are
shortened versions \texttt{pthread\_mutex\_lock} and
\texttt{pthread\_cond\_wait} etc. respectively

Also remember that \texttt{pthread\_cond\_wait} performs \emph{Three}
actions. Firstly it atomically unlocks the mutex and then sleeps (until
it is woken by \texttt{pthread\_cond\_signal} or
\texttt{pthread\_cond\_broadcast}). Thirdly the awoken thread must
re-acquire the mutex lock before returning. Thus only one thread can
actually be running inside the critical section defined by the lock and
unlock() methods.

Implementation \#3 below ensures that a reader will enter the cond\_wait
if there are any writers writing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{read() \{}
    \NormalTok{lock(&m)}
    \KeywordTok{while} \NormalTok{(writing)}
        \NormalTok{cond_wait(&cv, &m)}
    \NormalTok{reading++;}

\CommentTok{/* Read here! */}

    \NormalTok{reading--}
    \NormalTok{cond_signal(&cv)}
    \NormalTok{unlock(&m)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

However only one reader a time can read because candidate \#3 did not
unlock the mutex. A better version unlocks before reading :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{read() \{}
    \NormalTok{lock(&m);}
    \KeywordTok{while} \NormalTok{(writing)}
        \NormalTok{cond_wait(&cv, &m)}
    \NormalTok{reading++;}
    \NormalTok{unlock(&m)}
\CommentTok{/* Read here! */}
    \NormalTok{lock(&m)}
    \NormalTok{reading--}
    \NormalTok{cond_signal(&cv)}
    \NormalTok{unlock(&m)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Does this mean that a writer and read could read and write at the same
time? No! First of all, remember cond\_wait requires the thread
re-acquire the mutex lock before returning. Thus only one thread can be
executing code inside the critical section (marked with **) at a time!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{read() \{}
    \NormalTok{lock(&m);}
\NormalTok{**  }\KeywordTok{while} \NormalTok{(writing)}
\NormalTok{**      cond_wait(&cv, &m)}
\NormalTok{**  reading++;}
    \NormalTok{unlock(&m)}
\CommentTok{/* Read here! */}
    \NormalTok{lock(&m)}
\NormalTok{**  reading--}
\NormalTok{**  cond_signal(&cv)}
    \NormalTok{unlock(&m)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Writers must wait for everyone. Mutual exclusion is assured by the lock.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{write() \{}
    \NormalTok{lock(&m);}
\NormalTok{**  }\KeywordTok{while} \NormalTok{(reading || writing)}
\NormalTok{**      cond_wait(&cv, &m);}
\NormalTok{**  writing++;}
\NormalTok{**}
\NormalTok{** }\CommentTok{/* Write here! */}
\NormalTok{**  writing--;}
\NormalTok{**  cond_signal(&cv);}
    \NormalTok{unlock(&m);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Candidate \#3 above also uses \texttt{pthread\_cond\_signal} ; this will
only wake up one thread. For example, if many readers are waiting for
the writer to complete then only one sleeping reader will be awoken from
their slumber. The reader and writer should use \texttt{cond\_broadcast}
so that all threads should wake up and check their while-loop condition.

\subsection{Starving writers}\label{starving-writers}

Candidate \#3 above suffers from starvation. If readers are constantly
arriving then a writer will never be able to proceed (the `reading'
count never reduces to zero). This is known as \emph{starvation} and
would be discovered under heavy loads. Our fix is to implement a
bounded-wait for the writer. If a writer arrives they will still need to
wait for existing readers however future readers must be placed in a
``holding pen'' and wait for the writer to finish. The ``holding pen''
can be implemented using a variable and a condition variable (so that we
can wake up the threads once the writer has finished).

Our plan is that when a writer arrives, and before waiting for current
readers to finish, register our intent to write (by incrementing a
counter `writer'). Sketched below -

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{write() \{}
    \NormalTok{lock()}
    \NormalTok{writer++}

    \KeywordTok{while} \NormalTok{(reading | writing)}
    \NormalTok{cond_wait}
    \NormalTok{unlock()}
  \NormalTok{...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And incoming readers will not be allowed to continue while writer is
nonzero. Notice `writer' indicates a writer has arrived, while `reading'
and `writing' counters indicate there is an \emph{active} reader or
writer.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{read() \{}
    \NormalTok{lock()}
    \CommentTok{// readers that arrive *after* the writer arrived will have to wait here!}
    \KeywordTok{while}\NormalTok{(writer)}
    \NormalTok{cond_wait(&cv,&m)}

    \CommentTok{// readers that arrive while there is an active writer}
    \CommentTok{// will also wait.}
    \KeywordTok{while} \NormalTok{(writing) }
        \NormalTok{cond_wait(&cv,&m)}
    \NormalTok{reading++}
    \NormalTok{unlock}
  \NormalTok{...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Candidate solution \#4}\label{candidate-solution-4}

Below is our first working solution to the Reader-Writer problem.\\Note
if you continue to read about the ``Reader Writer problem'' then you
will discover that we solved the ``Second Reader Writer problem'' by
giving writers preferential access to the lock. This solution is not
optimal. However it satisfies our original problem (N active readers,
single active writer, avoids starvation of the writer if there is a
constant stream of readers).

Can you identify two improvements? Is any of the code superfluous? For
example, how would you improve the code so that we only woke up readers
or one writer?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reader() \{}
    \NormalTok{mutex_lock(&m)}
    \KeywordTok{while} \NormalTok{(writers)}
        \NormalTok{cond_wait(&turn, &m)}
    \KeywordTok{while} \NormalTok{(writing)}
        \NormalTok{cond_wait(&turn, &m)}
    \NormalTok{reading++}
    \NormalTok{unlock(&m)}

  \CommentTok{// perform reading here}

    \NormalTok{lock(&m)}
    \NormalTok{reading--}
    \NormalTok{cond_broadcast(&turn)}
    \NormalTok{unlock(&m)}
\NormalTok{\}}

\NormalTok{writer()\{}
    \NormalTok{lock(&m)  }
    \NormalTok{writers++  }
    \KeywordTok{while} \NormalTok{(reading || writing)   }
        \NormalTok{cond_wait(&turn, &m)  }
    \NormalTok{writing++  }
    \NormalTok{unlock(&m)  }
    \CommentTok{// perform writing here  }
    \NormalTok{lock(&m)  }
    \NormalTok{writing--  }
    \NormalTok{writers--  }
    \NormalTok{cond_broadcast(&turn)  }
    \NormalTok{unlock(&m)  }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

